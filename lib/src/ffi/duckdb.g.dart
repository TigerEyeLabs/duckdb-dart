// This file is generated by ffigen. Do not modify directly.
// coverage:ignore-file
// ignore_for_file: type = lint

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Auto-generated, internal bindings to DuckDB
class Bindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Bindings(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Bindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// !
  /// Creates a new database instance cache.
  /// The instance cache is necessary if a client/program (re)opens multiple databases to the same file within the same
  /// process. Must be destroyed with 'duckdb_destroy_instance_cache'.
  ///
  /// @return The database instance cache.
  duckdb_instance_cache duckdb_create_instance_cache() {
    return _duckdb_create_instance_cache();
  }

  late final _duckdb_create_instance_cachePtr =
      _lookup<ffi.NativeFunction<duckdb_instance_cache Function()>>(
          'duckdb_create_instance_cache');
  late final _duckdb_create_instance_cache = _duckdb_create_instance_cachePtr
      .asFunction<duckdb_instance_cache Function()>();

  /// !
  /// Creates a new database instance in the instance cache, or retrieves an existing database instance.
  /// Must be closed with 'duckdb_close'.
  ///
  /// @param instance_cache The instance cache in which to create the database, or from which to take the database.
  /// @param path Path to the database file on disk. Both `nullptr` and `:memory:` open or retrieve an in-memory database.
  /// @param out_database The resulting cached database.
  /// @param config (Optional) configuration used to create the database.
  /// @param out_error If set and the function returns `DuckDBError`, this contains the error message.
  /// Note that the error message must be freed using `duckdb_free`.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_get_or_create_from_cache(
    duckdb_instance_cache instance_cache,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<duckdb_database> out_database,
    duckdb_config config,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_error,
  ) {
    return duckdb_state.fromValue(_duckdb_get_or_create_from_cache(
      instance_cache,
      path,
      out_database,
      config,
      out_error,
    ));
  }

  late final _duckdb_get_or_create_from_cachePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_instance_cache,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<duckdb_database>,
                  duckdb_config,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'duckdb_get_or_create_from_cache');
  late final _duckdb_get_or_create_from_cache =
      _duckdb_get_or_create_from_cachePtr.asFunction<
          int Function(
              duckdb_instance_cache,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_database>,
              duckdb_config,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// !
  /// Destroys an existing database instance cache and de-allocates its memory.
  ///
  /// @param instance_cache The instance cache to destroy.
  void duckdb_destroy_instance_cache(
    ffi.Pointer<duckdb_instance_cache> instance_cache,
  ) {
    return _duckdb_destroy_instance_cache(
      instance_cache,
    );
  }

  late final _duckdb_destroy_instance_cachePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_instance_cache>)>>(
      'duckdb_destroy_instance_cache');
  late final _duckdb_destroy_instance_cache = _duckdb_destroy_instance_cachePtr
      .asFunction<void Function(ffi.Pointer<duckdb_instance_cache>)>();

  /// !
  /// Creates a new database or opens an existing database file stored at the given path.
  /// If no path is given a new in-memory database is created instead.
  /// The database must be closed with 'duckdb_close'.
  ///
  /// @param path Path to the database file on disk. Both `nullptr` and `:memory:` open an in-memory database.
  /// @param out_database The result database object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_open(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<duckdb_database> out_database,
  ) {
    return duckdb_state.fromValue(_duckdb_open(
      path,
      out_database,
    ));
  }

  late final _duckdb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_database>)>>('duckdb_open');
  late final _duckdb_open = _duckdb_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_database>)>();

  /// !
  /// Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.
  /// The database must be closed with 'duckdb_close'.
  ///
  /// @param path Path to the database file on disk. Both `nullptr` and `:memory:` open an in-memory database.
  /// @param out_database The result database object.
  /// @param config (Optional) configuration used to start up the database.
  /// @param out_error If set and the function returns `DuckDBError`, this contains the error message.
  /// Note that the error message must be freed using `duckdb_free`.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_open_ext(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<duckdb_database> out_database,
    duckdb_config config,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_error,
  ) {
    return duckdb_state.fromValue(_duckdb_open_ext(
      path,
      out_database,
      config,
      out_error,
    ));
  }

  late final _duckdb_open_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_database>,
              duckdb_config,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('duckdb_open_ext');
  late final _duckdb_open_ext = _duckdb_open_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_database>,
          duckdb_config, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// !
  /// Closes the specified database and de-allocates all memory allocated for that database.
  /// This should be called after you are done with any database allocated through `duckdb_open` or `duckdb_open_ext`.
  /// Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
  /// Still, it is recommended to always correctly close a database object after you are done with it.
  ///
  /// @param database The database object to shut down.
  void duckdb_close(
    ffi.Pointer<duckdb_database> database,
  ) {
    return _duckdb_close(
      database,
    );
  }

  late final _duckdb_closePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_database>)>>(
      'duckdb_close');
  late final _duckdb_close = _duckdb_closePtr
      .asFunction<void Function(ffi.Pointer<duckdb_database>)>();

  /// !
  /// Opens a connection to a database. Connections are required to query the database, and store transactional state
  /// associated with the connection.
  /// The instantiated connection should be closed using 'duckdb_disconnect'.
  ///
  /// @param database The database file to connect to.
  /// @param out_connection The result connection object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_connect(
    duckdb_database database,
    ffi.Pointer<duckdb_connection> out_connection,
  ) {
    return duckdb_state.fromValue(_duckdb_connect(
      database,
      out_connection,
    ));
  }

  late final _duckdb_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_database,
              ffi.Pointer<duckdb_connection>)>>('duckdb_connect');
  late final _duckdb_connect = _duckdb_connectPtr.asFunction<
      int Function(duckdb_database, ffi.Pointer<duckdb_connection>)>();

  /// !
  /// Interrupt running query
  ///
  /// @param connection The connection to interrupt
  void duckdb_interrupt(
    duckdb_connection connection,
  ) {
    return _duckdb_interrupt(
      connection,
    );
  }

  late final _duckdb_interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_connection)>>(
          'duckdb_interrupt');
  late final _duckdb_interrupt =
      _duckdb_interruptPtr.asFunction<void Function(duckdb_connection)>();

  /// !
  /// Get progress of the running query
  ///
  /// @param connection The working connection
  /// @return -1 if no progress or a percentage of the progress
  duckdb_query_progress_type duckdb_query_progress(
    duckdb_connection connection,
  ) {
    return _duckdb_query_progress(
      connection,
    );
  }

  late final _duckdb_query_progressPtr = _lookup<
      ffi.NativeFunction<
          duckdb_query_progress_type Function(
              duckdb_connection)>>('duckdb_query_progress');
  late final _duckdb_query_progress = _duckdb_query_progressPtr
      .asFunction<duckdb_query_progress_type Function(duckdb_connection)>();

  /// !
  /// Closes the specified connection and de-allocates all memory allocated for that connection.
  ///
  /// @param connection The connection to close.
  void duckdb_disconnect(
    ffi.Pointer<duckdb_connection> connection,
  ) {
    return _duckdb_disconnect(
      connection,
    );
  }

  late final _duckdb_disconnectPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_connection>)>>(
      'duckdb_disconnect');
  late final _duckdb_disconnect = _duckdb_disconnectPtr
      .asFunction<void Function(ffi.Pointer<duckdb_connection>)>();

  /// !
  /// Returns the version of the linked DuckDB, with a version postfix for dev versions
  ///
  /// Usually used for developing C extensions that must return this for a compatibility check.
  ffi.Pointer<ffi.Char> duckdb_library_version() {
    return _duckdb_library_version();
  }

  late final _duckdb_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'duckdb_library_version');
  late final _duckdb_library_version =
      _duckdb_library_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// !
  /// Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
  /// through `duckdb_open_ext`.
  /// The duckdb_config must be destroyed using 'duckdb_destroy_config'
  ///
  /// This will always succeed unless there is a malloc failure.
  ///
  /// Note that `duckdb_destroy_config` should always be called on the resulting config, even if the function returns
  /// `DuckDBError`.
  ///
  /// @param out_config The result configuration object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_create_config(
    ffi.Pointer<duckdb_config> out_config,
  ) {
    return duckdb_state.fromValue(_duckdb_create_config(
      out_config,
    ));
  }

  late final _duckdb_create_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<duckdb_config>)>>('duckdb_create_config');
  late final _duckdb_create_config = _duckdb_create_configPtr
      .asFunction<int Function(ffi.Pointer<duckdb_config>)>();

  /// !
  /// This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
  ///
  /// This should not be called in a loop as it internally loops over all the options.
  ///
  /// @return The amount of config options available.
  int duckdb_config_count() {
    return _duckdb_config_count();
  }

  late final _duckdb_config_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('duckdb_config_count');
  late final _duckdb_config_count =
      _duckdb_config_countPtr.asFunction<int Function()>();

  /// !
  /// Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
  /// display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
  ///
  /// The result name or description MUST NOT be freed.
  ///
  /// @param index The index of the configuration option (between 0 and `duckdb_config_count`)
  /// @param out_name A name of the configuration flag.
  /// @param out_description A description of the configuration flag.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_get_config_flag(
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_description,
  ) {
    return duckdb_state.fromValue(_duckdb_get_config_flag(
      index,
      out_name,
      out_description,
    ));
  }

  late final _duckdb_get_config_flagPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Size, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('duckdb_get_config_flag');
  late final _duckdb_get_config_flag = _duckdb_get_config_flagPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// !
  /// Sets the specified option for the specified configuration. The configuration option is indicated by name.
  /// To obtain a list of config options, see `duckdb_get_config_flag`.
  ///
  /// In the source code, configuration options are defined in `config.cpp`.
  ///
  /// This can fail if either the name is invalid, or if the value provided for the option is invalid.
  ///
  /// @param config The configuration object to set the option on.
  /// @param name The name of the configuration flag to set.
  /// @param option The value to set the configuration flag to.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_set_config(
    duckdb_config config,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> option,
  ) {
    return duckdb_state.fromValue(_duckdb_set_config(
      config,
      name,
      option,
    ));
  }

  late final _duckdb_set_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_config, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('duckdb_set_config');
  late final _duckdb_set_config = _duckdb_set_configPtr.asFunction<
      int Function(
          duckdb_config, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Destroys the specified configuration object and de-allocates all memory allocated for the object.
  ///
  /// @param config The configuration object to destroy.
  void duckdb_destroy_config(
    ffi.Pointer<duckdb_config> config,
  ) {
    return _duckdb_destroy_config(
      config,
    );
  }

  late final _duckdb_destroy_configPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_config>)>>(
      'duckdb_destroy_config');
  late final _duckdb_destroy_config = _duckdb_destroy_configPtr
      .asFunction<void Function(ffi.Pointer<duckdb_config>)>();

  /// !
  /// Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
  /// If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
  /// `duckdb_result_error`.
  ///
  /// Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
  /// query fails, otherwise the error stored within the result will not be freed correctly.
  ///
  /// @param connection The connection to perform the query in.
  /// @param query The SQL query to run.
  /// @param out_result The query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_query(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_query(
      connection,
      query,
      out_result,
    ));
  }

  late final _duckdb_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_result>)>>('duckdb_query');
  late final _duckdb_query = _duckdb_queryPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_result>)>();

  /// !
  /// Closes the result and de-allocates all memory allocated for that connection.
  ///
  /// @param result The result to destroy.
  void duckdb_destroy_result(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_destroy_result(
      result,
    );
  }

  late final _duckdb_destroy_resultPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_result>)>>(
      'duckdb_destroy_result');
  late final _duckdb_destroy_result = _duckdb_destroy_resultPtr
      .asFunction<void Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the column name of the specified column. The result should not need to be freed; the column names will
  /// automatically be destroyed when the result is destroyed.
  ///
  /// Returns `NULL` if the column is out of range.
  ///
  /// @param result The result object to fetch the column name from.
  /// @param col The column index.
  /// @return The column name of the specified column.
  ffi.Pointer<ffi.Char> duckdb_column_name(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_name(
      result,
      col,
    );
  }

  late final _duckdb_column_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_name');
  late final _duckdb_column_name = _duckdb_column_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the column type of the specified column.
  ///
  /// Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
  ///
  /// @param result The result object to fetch the column type from.
  /// @param col The column index.
  /// @return The column type of the specified column.
  DUCKDB_TYPE duckdb_column_type(
    ffi.Pointer<duckdb_result> result,
    Dartidx_t col,
  ) {
    return DUCKDB_TYPE.fromValue(_duckdb_column_type(
      result,
      col,
    ));
  }

  late final _duckdb_column_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_type');
  late final _duckdb_column_type = _duckdb_column_typePtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the statement type of the statement that was executed
  ///
  /// @param result The result object to fetch the statement type from.
  /// @return duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
  duckdb_statement_type duckdb_result_statement_type(
    duckdb_result result,
  ) {
    return duckdb_statement_type.fromValue(_duckdb_result_statement_type(
      result,
    ));
  }

  late final _duckdb_result_statement_typePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_result)>>(
          'duckdb_result_statement_type');
  late final _duckdb_result_statement_type = _duckdb_result_statement_typePtr
      .asFunction<int Function(duckdb_result)>();

  /// !
  /// Returns the logical column type of the specified column.
  ///
  /// The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// Returns `NULL` if the column is out of range.
  ///
  /// @param result The result object to fetch the column type from.
  /// @param col The column index.
  /// @return The logical column type of the specified column.
  duckdb_logical_type duckdb_column_logical_type(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_logical_type(
      result,
      col,
    );
  }

  late final _duckdb_column_logical_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_result>,
              idx_t)>>('duckdb_column_logical_type');
  late final _duckdb_column_logical_type =
      _duckdb_column_logical_typePtr.asFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the number of columns present in a the result object.
  ///
  /// @param result The result object.
  /// @return The number of columns present in the result object.
  int duckdb_column_count(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_column_count(
      result,
    );
  }

  late final _duckdb_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_column_count');
  late final _duckdb_column_count = _duckdb_column_countPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the number of rows present in the result object.
  ///
  /// @param result The result object.
  /// @return The number of rows present in the result object.
  int duckdb_row_count(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_row_count(
      result,
    );
  }

  late final _duckdb_row_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_row_count');
  late final _duckdb_row_count = _duckdb_row_countPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
  /// queries. For other queries the rows_changed will be 0.
  ///
  /// @param result The result object.
  /// @return The number of rows changed.
  int duckdb_rows_changed(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_rows_changed(
      result,
    );
  }

  late final _duckdb_rows_changedPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_rows_changed');
  late final _duckdb_rows_changed = _duckdb_rows_changedPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
  ///
  /// Returns the data of a specific column of a result in columnar format.
  ///
  /// The function returns a dense array which contains the result data. The exact type stored in the array depends on the
  /// corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
  /// accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
  ///
  /// For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
  /// ```c
  /// int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
  /// printf("Data for row %d: %d\n", row, data[row]);
  /// ```
  ///
  /// @param result The result object to fetch the column data from.
  /// @param col The column index.
  /// @return The column data of the specified column.
  ffi.Pointer<ffi.Void> duckdb_column_data(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_data(
      result,
      col,
    );
  }

  late final _duckdb_column_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_data');
  late final _duckdb_column_data = _duckdb_column_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
  ///
  /// Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
  /// whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
  /// by `duckdb_column_data` are undefined.
  ///
  /// ```c
  /// int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
  /// bool *nullmask = duckdb_nullmask_data(&result, 0);
  /// if (nullmask[row]) {
  /// printf("Data for row %d: NULL\n", row);
  /// } else {
  /// printf("Data for row %d: %d\n", row, data[row]);
  /// }
  /// ```
  ///
  /// @param result The result object to fetch the nullmask from.
  /// @param col The column index.
  /// @return The nullmask of the specified column.
  ffi.Pointer<ffi.Bool> duckdb_nullmask_data(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_nullmask_data(
      result,
      col,
    );
  }

  late final _duckdb_nullmask_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Bool> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_nullmask_data');
  late final _duckdb_nullmask_data = _duckdb_nullmask_dataPtr.asFunction<
      ffi.Pointer<ffi.Bool> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
  ///
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
  ///
  /// @param result The result object to fetch the error from.
  /// @return The error of the result.
  ffi.Pointer<ffi.Char> duckdb_result_error(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_result_error(
      result,
    );
  }

  late final _duckdb_result_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>)>>('duckdb_result_error');
  late final _duckdb_result_error = _duckdb_result_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the result error type contained within the result. The error is only set if `duckdb_query` returns
  /// `DuckDBError`.
  ///
  /// @param result The result object to fetch the error from.
  /// @return The error type of the result.
  duckdb_error_type duckdb_result_error_type(
    ffi.Pointer<duckdb_result> result,
  ) {
    return duckdb_error_type.fromValue(_duckdb_result_error_type(
      result,
    ));
  }

  late final _duckdb_result_error_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<duckdb_result>)>>('duckdb_result_error_type');
  late final _duckdb_result_error_type = _duckdb_result_error_typePtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
  ///
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
  /// functions. It results in significantly better performance, and should be preferred in newer code-bases.
  ///
  /// If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
  /// mixed with the legacy result functions).
  ///
  /// Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
  ///
  /// @param result The result object to fetch the data chunk from.
  /// @param chunk_index The chunk index to fetch from.
  /// @return The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
  duckdb_data_chunk duckdb_result_get_chunk(
    duckdb_result result,
    int chunk_index,
  ) {
    return _duckdb_result_get_chunk(
      result,
      chunk_index,
    );
  }

  late final _duckdb_result_get_chunkPtr = _lookup<
          ffi.NativeFunction<duckdb_data_chunk Function(duckdb_result, idx_t)>>(
      'duckdb_result_get_chunk');
  late final _duckdb_result_get_chunk = _duckdb_result_get_chunkPtr
      .asFunction<duckdb_data_chunk Function(duckdb_result, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Checks if the type of the internal result is StreamQueryResult.
  ///
  /// @param result The result object to check.
  /// @return Whether or not the result object is of the type StreamQueryResult
  bool duckdb_result_is_streaming(
    duckdb_result result,
  ) {
    return _duckdb_result_is_streaming(
      result,
    );
  }

  late final _duckdb_result_is_streamingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_result)>>(
          'duckdb_result_is_streaming');
  late final _duckdb_result_is_streaming =
      _duckdb_result_is_streamingPtr.asFunction<bool Function(duckdb_result)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the number of data chunks present in the result.
  ///
  /// @param result The result object
  /// @return Number of data chunks present in the result.
  int duckdb_result_chunk_count(
    duckdb_result result,
  ) {
    return _duckdb_result_chunk_count(
      result,
    );
  }

  late final _duckdb_result_chunk_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_result)>>(
          'duckdb_result_chunk_count');
  late final _duckdb_result_chunk_count =
      _duckdb_result_chunk_countPtr.asFunction<int Function(duckdb_result)>();

  /// !
  /// Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error
  ///
  /// @param result The result object
  /// @return The return_type
  duckdb_result_type duckdb_result_return_type(
    duckdb_result result,
  ) {
    return duckdb_result_type.fromValue(_duckdb_result_return_type(
      result,
    ));
  }

  late final _duckdb_result_return_typePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_result)>>(
          'duckdb_result_return_type');
  late final _duckdb_result_return_type =
      _duckdb_result_return_typePtr.asFunction<int Function(duckdb_result)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The boolean value at the specified location, or false if the value cannot be converted.
  bool duckdb_value_boolean(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_boolean(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_boolean');
  late final _duckdb_value_boolean = _duckdb_value_booleanPtr
      .asFunction<bool Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The int8_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int8(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int8(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int8 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int8');
  late final _duckdb_value_int8 = _duckdb_value_int8Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The int16_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int16(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int16(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int16');
  late final _duckdb_value_int16 = _duckdb_value_int16Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The int32_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int32(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int32(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int32');
  late final _duckdb_value_int32 = _duckdb_value_int32Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The int64_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int64(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int64(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int64');
  late final _duckdb_value_int64 = _duckdb_value_int64Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
  duckdb_hugeint duckdb_value_hugeint(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_hugeint(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_hugeintPtr = _lookup<
      ffi.NativeFunction<
          duckdb_hugeint Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_hugeint');
  late final _duckdb_value_hugeint = _duckdb_value_hugeintPtr.asFunction<
      duckdb_hugeint Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.
  duckdb_uhugeint duckdb_value_uhugeint(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uhugeint(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uhugeintPtr = _lookup<
      ffi.NativeFunction<
          duckdb_uhugeint Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uhugeint');
  late final _duckdb_value_uhugeint = _duckdb_value_uhugeintPtr.asFunction<
      duckdb_uhugeint Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.
  duckdb_decimal duckdb_value_decimal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_decimal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_decimalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_decimal Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_decimal');
  late final _duckdb_value_decimal = _duckdb_value_decimalPtr.asFunction<
      duckdb_decimal Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The uint8_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint8(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint8(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_uint8');
  late final _duckdb_value_uint8 = _duckdb_value_uint8Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The uint16_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint16(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint16(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint16 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint16');
  late final _duckdb_value_uint16 = _duckdb_value_uint16Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The uint32_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint32(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint32(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint32');
  late final _duckdb_value_uint32 = _duckdb_value_uint32Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The uint64_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint64(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint64(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint64');
  late final _duckdb_value_uint64 = _duckdb_value_uint64Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The float value at the specified location, or 0 if the value cannot be converted.
  double duckdb_value_float(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_float(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_float');
  late final _duckdb_value_float = _duckdb_value_floatPtr
      .asFunction<double Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The double value at the specified location, or 0 if the value cannot be converted.
  double duckdb_value_double(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_double(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_double');
  late final _duckdb_value_double = _duckdb_value_doublePtr
      .asFunction<double Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_date value at the specified location, or 0 if the value cannot be converted.
  duckdb_date duckdb_value_date(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_date(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_datePtr = _lookup<
      ffi.NativeFunction<
          duckdb_date Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_date');
  late final _duckdb_value_date = _duckdb_value_datePtr
      .asFunction<duckdb_date Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_time value at the specified location, or 0 if the value cannot be converted.
  duckdb_time duckdb_value_time(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_time(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_timePtr = _lookup<
      ffi.NativeFunction<
          duckdb_time Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_time');
  late final _duckdb_value_time = _duckdb_value_timePtr
      .asFunction<duckdb_time Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
  duckdb_timestamp duckdb_value_timestamp(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_timestamp(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_timestampPtr = _lookup<
      ffi.NativeFunction<
          duckdb_timestamp Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_timestamp');
  late final _duckdb_value_timestamp = _duckdb_value_timestampPtr.asFunction<
      duckdb_timestamp Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
  duckdb_interval duckdb_value_interval(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_interval(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_intervalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_interval Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_interval');
  late final _duckdb_value_interval = _duckdb_value_intervalPtr.asFunction<
      duckdb_interval Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED**: Use duckdb_value_string instead. This function does not work correctly if the string contains null
  /// bytes.
  ///
  /// @return The text value at the specified location as a null-terminated string, or nullptr if the value cannot be
  /// converted. The result must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_value_varchar(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_varchar(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_varchar');
  late final _duckdb_value_varchar = _duckdb_value_varcharPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// No support for nested types, and for other complex types.
  /// The resulting field "string.data" must be freed with `duckdb_free.`
  ///
  /// @return The string value at the specified location. Attempts to cast the result value to string.
  duckdb_string duckdb_value_string(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_string(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_stringPtr = _lookup<
      ffi.NativeFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_string');
  late final _duckdb_value_string = _duckdb_value_stringPtr.asFunction<
      duckdb_string Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED**: Use duckdb_value_string_internal instead. This function does not work correctly if the string contains
  /// null bytes.
  ///
  /// @return The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
  /// If the column is NOT a VARCHAR column this function will return NULL.
  ///
  /// The result must NOT be freed.
  ffi.Pointer<ffi.Char> duckdb_value_varchar_internal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_varchar_internal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_varchar_internalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_varchar_internal');
  late final _duckdb_value_varchar_internal =
      _duckdb_value_varchar_internalPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED**: Use duckdb_value_string_internal instead. This function does not work correctly if the string contains
  /// null bytes.
  /// @return The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
  /// If the column is NOT a VARCHAR column this function will return NULL.
  ///
  /// The result must NOT be freed.
  duckdb_string duckdb_value_string_internal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_string_internal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_string_internalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_string_internal');
  late final _duckdb_value_string_internal =
      _duckdb_value_string_internalPtr.asFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
  /// value cannot be converted. The resulting field "blob.data" must be freed with `duckdb_free.`
  duckdb_blob duckdb_value_blob(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_blob(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_blobPtr = _lookup<
      ffi.NativeFunction<
          duckdb_blob Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_blob');
  late final _duckdb_value_blob = _duckdb_value_blobPtr
      .asFunction<duckdb_blob Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// @return Returns true if the value at the specified index is NULL, and false otherwise.
  bool duckdb_value_is_null(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_is_null(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_is_nullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_is_null');
  late final _duckdb_value_is_null = _duckdb_value_is_nullPtr
      .asFunction<bool Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
  /// should be freed using `duckdb_free`.
  ///
  /// @param size The number of bytes to allocate.
  /// @return A pointer to the allocated memory region.
  ffi.Pointer<ffi.Void> duckdb_malloc(
    int size,
  ) {
    return _duckdb_malloc(
      size,
    );
  }

  late final _duckdb_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'duckdb_malloc');
  late final _duckdb_malloc =
      _duckdb_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// !
  /// Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_value_blob`, or
  /// `duckdb_value_string`.
  ///
  /// @param ptr The memory region to de-allocate.
  void duckdb_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _duckdb_free(
      ptr,
    );
  }

  late final _duckdb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'duckdb_free');
  late final _duckdb_free =
      _duckdb_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// !
  /// The internal vector size used by DuckDB.
  /// This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
  ///
  /// @return The vector size.
  int duckdb_vector_size() {
    return _duckdb_vector_size();
  }

  late final _duckdb_vector_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function()>>('duckdb_vector_size');
  late final _duckdb_vector_size =
      _duckdb_vector_sizePtr.asFunction<int Function()>();

  /// !
  /// Whether or not the duckdb_string_t value is inlined.
  /// This means that the data of the string does not have a separate allocation.
  bool duckdb_string_is_inlined(
    duckdb_string_t string,
  ) {
    return _duckdb_string_is_inlined(
      string,
    );
  }

  late final _duckdb_string_is_inlinedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_string_t)>>(
          'duckdb_string_is_inlined');
  late final _duckdb_string_is_inlined =
      _duckdb_string_is_inlinedPtr.asFunction<bool Function(duckdb_string_t)>();

  /// !
  /// Get the string length of a string_t
  ///
  /// @param string The string to get the length of.
  /// @return The length.
  int duckdb_string_t_length(
    duckdb_string_t string,
  ) {
    return _duckdb_string_t_length(
      string,
    );
  }

  late final _duckdb_string_t_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(duckdb_string_t)>>(
          'duckdb_string_t_length');
  late final _duckdb_string_t_length =
      _duckdb_string_t_lengthPtr.asFunction<int Function(duckdb_string_t)>();

  /// !
  /// Get a pointer to the string data of a string_t
  ///
  /// @param string The string to get the pointer to.
  /// @return The pointer.
  ffi.Pointer<ffi.Char> duckdb_string_t_data(
    ffi.Pointer<duckdb_string_t> string,
  ) {
    return _duckdb_string_t_data(
      string,
    );
  }

  late final _duckdb_string_t_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_string_t>)>>('duckdb_string_t_data');
  late final _duckdb_string_t_data = _duckdb_string_t_dataPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_string_t>)>();

  /// !
  /// Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
  ///
  /// @param date The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
  /// @return The `duckdb_date_struct` with the decomposed elements.
  duckdb_date_struct duckdb_from_date(
    duckdb_date date,
  ) {
    return _duckdb_from_date(
      date,
    );
  }

  late final _duckdb_from_datePtr =
      _lookup<ffi.NativeFunction<duckdb_date_struct Function(duckdb_date)>>(
          'duckdb_from_date');
  late final _duckdb_from_date = _duckdb_from_datePtr
      .asFunction<duckdb_date_struct Function(duckdb_date)>();

  /// !
  /// Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
  ///
  /// @param date The year, month and date stored in a `duckdb_date_struct`.
  /// @return The `duckdb_date` element.
  duckdb_date duckdb_to_date(
    duckdb_date_struct date,
  ) {
    return _duckdb_to_date(
      date,
    );
  }

  late final _duckdb_to_datePtr =
      _lookup<ffi.NativeFunction<duckdb_date Function(duckdb_date_struct)>>(
          'duckdb_to_date');
  late final _duckdb_to_date =
      _duckdb_to_datePtr.asFunction<duckdb_date Function(duckdb_date_struct)>();

  /// !
  /// Test a `duckdb_date` to see if it is a finite value.
  ///
  /// @param date The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
  /// @return True if the date is finite, false if it is ±infinity.
  bool duckdb_is_finite_date(
    duckdb_date date,
  ) {
    return _duckdb_is_finite_date(
      date,
    );
  }

  late final _duckdb_is_finite_datePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_date)>>(
          'duckdb_is_finite_date');
  late final _duckdb_is_finite_date =
      _duckdb_is_finite_datePtr.asFunction<bool Function(duckdb_date)>();

  /// !
  /// Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
  ///
  /// @param time The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
  /// @return The `duckdb_time_struct` with the decomposed elements.
  duckdb_time_struct duckdb_from_time(
    duckdb_time time,
  ) {
    return _duckdb_from_time(
      time,
    );
  }

  late final _duckdb_from_timePtr =
      _lookup<ffi.NativeFunction<duckdb_time_struct Function(duckdb_time)>>(
          'duckdb_from_time');
  late final _duckdb_from_time = _duckdb_from_timePtr
      .asFunction<duckdb_time_struct Function(duckdb_time)>();

  /// !
  /// Create a `duckdb_time_tz` object from micros and a timezone offset.
  ///
  /// @param micros The microsecond component of the time.
  /// @param offset The timezone offset component of the time.
  /// @return The `duckdb_time_tz` element.
  duckdb_time_tz duckdb_create_time_tz(
    int micros,
    int offset,
  ) {
    return _duckdb_create_time_tz(
      micros,
      offset,
    );
  }

  late final _duckdb_create_time_tzPtr = _lookup<
          ffi.NativeFunction<duckdb_time_tz Function(ffi.Int64, ffi.Int32)>>(
      'duckdb_create_time_tz');
  late final _duckdb_create_time_tz =
      _duckdb_create_time_tzPtr.asFunction<duckdb_time_tz Function(int, int)>();

  /// !
  /// Decompose a TIME_TZ objects into micros and a timezone offset.
  ///
  /// Use `duckdb_from_time` to further decompose the micros into hour, minute, second and microsecond.
  ///
  /// @param micros The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.
  duckdb_time_tz_struct duckdb_from_time_tz(
    duckdb_time_tz micros,
  ) {
    return _duckdb_from_time_tz(
      micros,
    );
  }

  late final _duckdb_from_time_tzPtr = _lookup<
          ffi.NativeFunction<duckdb_time_tz_struct Function(duckdb_time_tz)>>(
      'duckdb_from_time_tz');
  late final _duckdb_from_time_tz = _duckdb_from_time_tzPtr
      .asFunction<duckdb_time_tz_struct Function(duckdb_time_tz)>();

  /// !
  /// Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
  ///
  /// @param time The hour, minute, second and microsecond in a `duckdb_time_struct`.
  /// @return The `duckdb_time` element.
  duckdb_time duckdb_to_time(
    duckdb_time_struct time,
  ) {
    return _duckdb_to_time(
      time,
    );
  }

  late final _duckdb_to_timePtr =
      _lookup<ffi.NativeFunction<duckdb_time Function(duckdb_time_struct)>>(
          'duckdb_to_time');
  late final _duckdb_to_time =
      _duckdb_to_timePtr.asFunction<duckdb_time Function(duckdb_time_struct)>();

  /// !
  /// Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
  ///
  /// @param ts The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
  /// @return The `duckdb_timestamp_struct` with the decomposed elements.
  duckdb_timestamp_struct duckdb_from_timestamp(
    duckdb_timestamp ts,
  ) {
    return _duckdb_from_timestamp(
      ts,
    );
  }

  late final _duckdb_from_timestampPtr = _lookup<
          ffi
          .NativeFunction<duckdb_timestamp_struct Function(duckdb_timestamp)>>(
      'duckdb_from_timestamp');
  late final _duckdb_from_timestamp = _duckdb_from_timestampPtr
      .asFunction<duckdb_timestamp_struct Function(duckdb_timestamp)>();

  /// !
  /// Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
  ///
  /// @param ts The de-composed elements in a `duckdb_timestamp_struct`.
  /// @return The `duckdb_timestamp` element.
  duckdb_timestamp duckdb_to_timestamp(
    duckdb_timestamp_struct ts,
  ) {
    return _duckdb_to_timestamp(
      ts,
    );
  }

  late final _duckdb_to_timestampPtr = _lookup<
          ffi
          .NativeFunction<duckdb_timestamp Function(duckdb_timestamp_struct)>>(
      'duckdb_to_timestamp');
  late final _duckdb_to_timestamp = _duckdb_to_timestampPtr
      .asFunction<duckdb_timestamp Function(duckdb_timestamp_struct)>();

  /// !
  /// Test a `duckdb_timestamp` to see if it is a finite value.
  ///
  /// @param ts The duckdb_timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
  /// @return True if the timestamp is finite, false if it is ±infinity.
  bool duckdb_is_finite_timestamp(
    duckdb_timestamp ts,
  ) {
    return _duckdb_is_finite_timestamp(
      ts,
    );
  }

  late final _duckdb_is_finite_timestampPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_timestamp)>>(
          'duckdb_is_finite_timestamp');
  late final _duckdb_is_finite_timestamp = _duckdb_is_finite_timestampPtr
      .asFunction<bool Function(duckdb_timestamp)>();

  /// !
  /// Test a `duckdb_timestamp_s` to see if it is a finite value.
  ///
  /// @param ts The duckdb_timestamp_s object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_S` column.
  /// @return True if the timestamp is finite, false if it is ±infinity.
  bool duckdb_is_finite_timestamp_s(
    duckdb_timestamp_s ts,
  ) {
    return _duckdb_is_finite_timestamp_s(
      ts,
    );
  }

  late final _duckdb_is_finite_timestamp_sPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_timestamp_s)>>(
          'duckdb_is_finite_timestamp_s');
  late final _duckdb_is_finite_timestamp_s = _duckdb_is_finite_timestamp_sPtr
      .asFunction<bool Function(duckdb_timestamp_s)>();

  /// !
  /// Test a `duckdb_timestamp_ms` to see if it is a finite value.
  ///
  /// @param ts The duckdb_timestamp_ms object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_MS` column.
  /// @return True if the timestamp is finite, false if it is ±infinity.
  bool duckdb_is_finite_timestamp_ms(
    duckdb_timestamp_ms ts,
  ) {
    return _duckdb_is_finite_timestamp_ms(
      ts,
    );
  }

  late final _duckdb_is_finite_timestamp_msPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_timestamp_ms)>>(
          'duckdb_is_finite_timestamp_ms');
  late final _duckdb_is_finite_timestamp_ms = _duckdb_is_finite_timestamp_msPtr
      .asFunction<bool Function(duckdb_timestamp_ms)>();

  /// !
  /// Test a `duckdb_timestamp_ns` to see if it is a finite value.
  ///
  /// @param ts The duckdb_timestamp_ns object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_NS` column.
  /// @return True if the timestamp is finite, false if it is ±infinity.
  bool duckdb_is_finite_timestamp_ns(
    duckdb_timestamp_ns ts,
  ) {
    return _duckdb_is_finite_timestamp_ns(
      ts,
    );
  }

  late final _duckdb_is_finite_timestamp_nsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_timestamp_ns)>>(
          'duckdb_is_finite_timestamp_ns');
  late final _duckdb_is_finite_timestamp_ns = _duckdb_is_finite_timestamp_nsPtr
      .asFunction<bool Function(duckdb_timestamp_ns)>();

  /// !
  /// Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
  ///
  /// @param val The hugeint value.
  /// @return The converted `double` element.
  double duckdb_hugeint_to_double(
    duckdb_hugeint val,
  ) {
    return _duckdb_hugeint_to_double(
      val,
    );
  }

  late final _duckdb_hugeint_to_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_hugeint)>>(
          'duckdb_hugeint_to_double');
  late final _duckdb_hugeint_to_double = _duckdb_hugeint_to_doublePtr
      .asFunction<double Function(duckdb_hugeint)>();

  /// !
  /// Converts a double value to a duckdb_hugeint object.
  ///
  /// If the conversion fails because the double value is too big the result will be 0.
  ///
  /// @param val The double value.
  /// @return The converted `duckdb_hugeint` element.
  duckdb_hugeint duckdb_double_to_hugeint(
    double val,
  ) {
    return _duckdb_double_to_hugeint(
      val,
    );
  }

  late final _duckdb_double_to_hugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_hugeint Function(ffi.Double)>>(
          'duckdb_double_to_hugeint');
  late final _duckdb_double_to_hugeint = _duckdb_double_to_hugeintPtr
      .asFunction<duckdb_hugeint Function(double)>();

  /// !
  /// Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` column) into a double.
  ///
  /// @param val The uhugeint value.
  /// @return The converted `double` element.
  double duckdb_uhugeint_to_double(
    duckdb_uhugeint val,
  ) {
    return _duckdb_uhugeint_to_double(
      val,
    );
  }

  late final _duckdb_uhugeint_to_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_uhugeint)>>(
          'duckdb_uhugeint_to_double');
  late final _duckdb_uhugeint_to_double = _duckdb_uhugeint_to_doublePtr
      .asFunction<double Function(duckdb_uhugeint)>();

  /// !
  /// Converts a double value to a duckdb_uhugeint object.
  ///
  /// If the conversion fails because the double value is too big the result will be 0.
  ///
  /// @param val The double value.
  /// @return The converted `duckdb_uhugeint` element.
  duckdb_uhugeint duckdb_double_to_uhugeint(
    double val,
  ) {
    return _duckdb_double_to_uhugeint(
      val,
    );
  }

  late final _duckdb_double_to_uhugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_uhugeint Function(ffi.Double)>>(
          'duckdb_double_to_uhugeint');
  late final _duckdb_double_to_uhugeint = _duckdb_double_to_uhugeintPtr
      .asFunction<duckdb_uhugeint Function(double)>();

  /// !
  /// Converts a double value to a duckdb_decimal object.
  ///
  /// If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.
  ///
  /// @param val The double value.
  /// @return The converted `duckdb_decimal` element.
  duckdb_decimal duckdb_double_to_decimal(
    double val,
    int width,
    int scale,
  ) {
    return _duckdb_double_to_decimal(
      val,
      width,
      scale,
    );
  }

  late final _duckdb_double_to_decimalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_decimal Function(
              ffi.Double, ffi.Uint8, ffi.Uint8)>>('duckdb_double_to_decimal');
  late final _duckdb_double_to_decimal = _duckdb_double_to_decimalPtr
      .asFunction<duckdb_decimal Function(double, int, int)>();

  /// !
  /// Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.
  ///
  /// @param val The decimal value.
  /// @return The converted `double` element.
  double duckdb_decimal_to_double(
    duckdb_decimal val,
  ) {
    return _duckdb_decimal_to_double(
      val,
    );
  }

  late final _duckdb_decimal_to_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_decimal)>>(
          'duckdb_decimal_to_double');
  late final _duckdb_decimal_to_double = _duckdb_decimal_to_doublePtr
      .asFunction<double Function(duckdb_decimal)>();

  /// !
  /// Create a prepared statement object from a query.
  ///
  /// Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
  /// `duckdb_destroy_prepare`, even if the prepare fails.
  ///
  /// If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
  ///
  /// @param connection The connection object
  /// @param query The SQL query to prepare
  /// @param out_prepared_statement The resulting prepared statement object
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_prepare(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_prepared_statement> out_prepared_statement,
  ) {
    return duckdb_state.fromValue(_duckdb_prepare(
      connection,
      query,
      out_prepared_statement,
    ));
  }

  late final _duckdb_preparePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_prepared_statement>)>>('duckdb_prepare');
  late final _duckdb_prepare = _duckdb_preparePtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Closes the prepared statement and de-allocates all memory allocated for the statement.
  ///
  /// @param prepared_statement The prepared statement to destroy.
  void duckdb_destroy_prepare(
    ffi.Pointer<duckdb_prepared_statement> prepared_statement,
  ) {
    return _duckdb_destroy_prepare(
      prepared_statement,
    );
  }

  late final _duckdb_destroy_preparePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_prepared_statement>)>>(
      'duckdb_destroy_prepare');
  late final _duckdb_destroy_prepare = _duckdb_destroy_preparePtr
      .asFunction<void Function(ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Returns the error message associated with the given prepared statement.
  /// If the prepared statement has no error message, this returns `nullptr` instead.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
  ///
  /// @param prepared_statement The prepared statement to obtain the error from.
  /// @return The error message, or `nullptr` if there is none.
  ffi.Pointer<ffi.Char> duckdb_prepare_error(
    duckdb_prepared_statement prepared_statement,
  ) {
    return _duckdb_prepare_error(
      prepared_statement,
    );
  }

  late final _duckdb_prepare_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_prepared_statement)>>('duckdb_prepare_error');
  late final _duckdb_prepare_error = _duckdb_prepare_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_prepared_statement)>();

  /// !
  /// Returns the number of parameters that can be provided to the given prepared statement.
  ///
  /// Returns 0 if the query was not successfully prepared.
  ///
  /// @param prepared_statement The prepared statement to obtain the number of parameters for.
  int duckdb_nparams(
    duckdb_prepared_statement prepared_statement,
  ) {
    return _duckdb_nparams(
      prepared_statement,
    );
  }

  late final _duckdb_nparamsPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_prepared_statement)>>(
          'duckdb_nparams');
  late final _duckdb_nparams =
      _duckdb_nparamsPtr.asFunction<int Function(duckdb_prepared_statement)>();

  /// !
  /// Returns the name used to identify the parameter
  /// The returned string should be freed using `duckdb_free`.
  ///
  /// Returns NULL if the index is out of range for the provided prepared statement.
  ///
  /// @param prepared_statement The prepared statement for which to get the parameter name from.
  ffi.Pointer<ffi.Char> duckdb_parameter_name(
    duckdb_prepared_statement prepared_statement,
    int index,
  ) {
    return _duckdb_parameter_name(
      prepared_statement,
      index,
    );
  }

  late final _duckdb_parameter_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_parameter_name');
  late final _duckdb_parameter_name = _duckdb_parameter_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(duckdb_prepared_statement, int)>();

  /// !
  /// Returns the parameter type for the parameter at the given index.
  ///
  /// Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
  ///
  /// @param prepared_statement The prepared statement.
  /// @param param_idx The parameter index.
  /// @return The parameter type
  DUCKDB_TYPE duckdb_param_type(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
  ) {
    return DUCKDB_TYPE.fromValue(_duckdb_param_type(
      prepared_statement,
      param_idx,
    ));
  }

  late final _duckdb_param_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_param_type');
  late final _duckdb_param_type = _duckdb_param_typePtr
      .asFunction<int Function(duckdb_prepared_statement, int)>();

  /// !
  /// Returns the logical type for the parameter at the given index.
  ///
  /// Returns `nullptr` if the parameter index is out of range or the statement was not successfully prepared.
  ///
  /// The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param prepared_statement The prepared statement.
  /// @param param_idx The parameter index.
  /// @return The logical type of the parameter
  duckdb_logical_type duckdb_param_logical_type(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
  ) {
    return _duckdb_param_logical_type(
      prepared_statement,
      param_idx,
    );
  }

  late final _duckdb_param_logical_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_param_logical_type');
  late final _duckdb_param_logical_type =
      _duckdb_param_logical_typePtr.asFunction<
          duckdb_logical_type Function(duckdb_prepared_statement, int)>();

  /// !
  /// Clear the params bind to the prepared statement.
  duckdb_state duckdb_clear_bindings(
    duckdb_prepared_statement prepared_statement,
  ) {
    return duckdb_state.fromValue(_duckdb_clear_bindings(
      prepared_statement,
    ));
  }

  late final _duckdb_clear_bindingsPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(duckdb_prepared_statement)>>(
      'duckdb_clear_bindings');
  late final _duckdb_clear_bindings = _duckdb_clear_bindingsPtr
      .asFunction<int Function(duckdb_prepared_statement)>();

  /// !
  /// Returns the statement type of the statement to be executed
  ///
  /// @param statement The prepared statement.
  /// @return duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
  duckdb_statement_type duckdb_prepared_statement_type(
    duckdb_prepared_statement statement,
  ) {
    return duckdb_statement_type.fromValue(_duckdb_prepared_statement_type(
      statement,
    ));
  }

  late final _duckdb_prepared_statement_typePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(duckdb_prepared_statement)>>(
      'duckdb_prepared_statement_type');
  late final _duckdb_prepared_statement_type =
      _duckdb_prepared_statement_typePtr
          .asFunction<int Function(duckdb_prepared_statement)>();

  /// !
  /// Binds a value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_value(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_value val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_value(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_value)>>('duckdb_bind_value');
  late final _duckdb_bind_value = _duckdb_bind_valuePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_value)>();

  /// !
  /// Retrieve the index of the parameter for the prepared statement, identified by name
  duckdb_state duckdb_bind_parameter_index(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<idx_t> param_idx_out,
    ffi.Pointer<ffi.Char> name,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_parameter_index(
      prepared_statement,
      param_idx_out,
      name,
    ));
  }

  late final _duckdb_bind_parameter_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_prepared_statement,
              ffi.Pointer<idx_t>,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_parameter_index');
  late final _duckdb_bind_parameter_index =
      _duckdb_bind_parameter_indexPtr.asFunction<
          int Function(duckdb_prepared_statement, ffi.Pointer<idx_t>,
              ffi.Pointer<ffi.Char>)>();

  /// !
  /// Binds a bool value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_boolean(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    bool val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_boolean(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Bool)>>('duckdb_bind_boolean');
  late final _duckdb_bind_boolean = _duckdb_bind_booleanPtr
      .asFunction<int Function(duckdb_prepared_statement, int, bool)>();

  /// !
  /// Binds an int8_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_int8(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_int8(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_int8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_prepared_statement, idx_t, ffi.Int8)>>('duckdb_bind_int8');
  late final _duckdb_bind_int8 = _duckdb_bind_int8Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int16_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_int16(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_int16(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_int16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Int16)>>('duckdb_bind_int16');
  late final _duckdb_bind_int16 = _duckdb_bind_int16Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int32_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_int32(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_int32(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Int32)>>('duckdb_bind_int32');
  late final _duckdb_bind_int32 = _duckdb_bind_int32Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int64_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_int64(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_int64(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Int64)>>('duckdb_bind_int64');
  late final _duckdb_bind_int64 = _duckdb_bind_int64Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds a duckdb_hugeint value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_hugeint(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_hugeint val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_hugeint(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_hugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_hugeint)>>('duckdb_bind_hugeint');
  late final _duckdb_bind_hugeint = _duckdb_bind_hugeintPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_hugeint)>();

  /// !
  /// Binds an duckdb_uhugeint value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_uhugeint(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_uhugeint val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_uhugeint(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_uhugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_uhugeint)>>('duckdb_bind_uhugeint');
  late final _duckdb_bind_uhugeint = _duckdb_bind_uhugeintPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_uhugeint)>();

  /// !
  /// Binds a duckdb_decimal value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_decimal(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_decimal val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_decimal(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_decimalPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_decimal)>>('duckdb_bind_decimal');
  late final _duckdb_bind_decimal = _duckdb_bind_decimalPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_decimal)>();

  /// !
  /// Binds an uint8_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_uint8(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_uint8(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_uint8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Uint8)>>('duckdb_bind_uint8');
  late final _duckdb_bind_uint8 = _duckdb_bind_uint8Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint16_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_uint16(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_uint16(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_uint16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Uint16)>>('duckdb_bind_uint16');
  late final _duckdb_bind_uint16 = _duckdb_bind_uint16Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint32_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_uint32(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_uint32(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Uint32)>>('duckdb_bind_uint32');
  late final _duckdb_bind_uint32 = _duckdb_bind_uint32Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint64_t value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_uint64(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    int val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_uint64(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Uint64)>>('duckdb_bind_uint64');
  late final _duckdb_bind_uint64 = _duckdb_bind_uint64Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds a float value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_float(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    double val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_float(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Float)>>('duckdb_bind_float');
  late final _duckdb_bind_float = _duckdb_bind_floatPtr
      .asFunction<int Function(duckdb_prepared_statement, int, double)>();

  /// !
  /// Binds a double value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_double(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    double val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_double(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Double)>>('duckdb_bind_double');
  late final _duckdb_bind_double = _duckdb_bind_doublePtr
      .asFunction<int Function(duckdb_prepared_statement, int, double)>();

  /// !
  /// Binds a duckdb_date value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_date(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_date val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_date(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_datePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_date)>>('duckdb_bind_date');
  late final _duckdb_bind_date = _duckdb_bind_datePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_date)>();

  /// !
  /// Binds a duckdb_time value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_time(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_time val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_time(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_time)>>('duckdb_bind_time');
  late final _duckdb_bind_time = _duckdb_bind_timePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_time)>();

  /// !
  /// Binds a duckdb_timestamp value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_timestamp(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_timestamp val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_timestamp(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_timestamp)>>('duckdb_bind_timestamp');
  late final _duckdb_bind_timestamp = _duckdb_bind_timestampPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_timestamp)>();

  /// !
  /// Binds a duckdb_timestamp value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_timestamp_tz(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_timestamp val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_timestamp_tz(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_timestamp_tzPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_timestamp)>>('duckdb_bind_timestamp_tz');
  late final _duckdb_bind_timestamp_tz =
      _duckdb_bind_timestamp_tzPtr.asFunction<
          int Function(duckdb_prepared_statement, int, duckdb_timestamp)>();

  /// !
  /// Binds a duckdb_interval value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_interval(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    duckdb_interval val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_interval(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              duckdb_interval)>>('duckdb_bind_interval');
  late final _duckdb_bind_interval = _duckdb_bind_intervalPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_interval)>();

  /// !
  /// Binds a null-terminated varchar value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_varchar(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    ffi.Pointer<ffi.Char> val,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_varchar(
      prepared_statement,
      param_idx,
      val,
    ));
  }

  late final _duckdb_bind_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_varchar');
  late final _duckdb_bind_varchar = _duckdb_bind_varcharPtr.asFunction<
      int Function(duckdb_prepared_statement, int, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Binds a varchar value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_varchar_length(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    ffi.Pointer<ffi.Char> val,
    Dartidx_t length,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_varchar_length(
      prepared_statement,
      param_idx,
      val,
      length,
    ));
  }

  late final _duckdb_bind_varchar_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Char>, idx_t)>>('duckdb_bind_varchar_length');
  late final _duckdb_bind_varchar_length =
      _duckdb_bind_varchar_lengthPtr.asFunction<
          int Function(
              duckdb_prepared_statement, int, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Binds a blob value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_blob(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
    ffi.Pointer<ffi.Void> data,
    Dartidx_t length,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_blob(
      prepared_statement,
      param_idx,
      data,
      length,
    ));
  }

  late final _duckdb_bind_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Void>, idx_t)>>('duckdb_bind_blob');
  late final _duckdb_bind_blob = _duckdb_bind_blobPtr.asFunction<
      int Function(
          duckdb_prepared_statement, int, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// Binds a NULL value to the prepared statement at the specified index.
  duckdb_state duckdb_bind_null(
    duckdb_prepared_statement prepared_statement,
    Dartidx_t param_idx,
  ) {
    return duckdb_state.fromValue(_duckdb_bind_null(
      prepared_statement,
      param_idx,
    ));
  }

  late final _duckdb_bind_nullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_bind_null');
  late final _duckdb_bind_null = _duckdb_bind_nullPtr
      .asFunction<int Function(duckdb_prepared_statement, int)>();

  /// !
  /// Executes the prepared statement with the given bound parameters, and returns a materialized query result.
  ///
  /// This method can be called multiple times for each prepared statement, and the parameters can be modified
  /// between calls to this function.
  ///
  /// Note that the result must be freed with `duckdb_destroy_result`.
  ///
  /// @param prepared_statement The prepared statement to execute.
  /// @param out_result The query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_execute_prepared(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_execute_prepared(
      prepared_statement,
      out_result,
    ));
  }

  late final _duckdb_execute_preparedPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_result>)>>('duckdb_execute_prepared');
  late final _duckdb_execute_prepared = _duckdb_execute_preparedPtr.asFunction<
      int Function(duckdb_prepared_statement, ffi.Pointer<duckdb_result>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.
  /// To determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`
  ///
  /// This method can be called multiple times for each prepared statement, and the parameters can be modified
  /// between calls to this function.
  ///
  /// Note that the result must be freed with `duckdb_destroy_result`.
  ///
  /// @param prepared_statement The prepared statement to execute.
  /// @param out_result The query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_execute_prepared_streaming(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_execute_prepared_streaming(
      prepared_statement,
      out_result,
    ));
  }

  late final _duckdb_execute_prepared_streamingPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_prepared_statement, ffi.Pointer<duckdb_result>)>>(
      'duckdb_execute_prepared_streaming');
  late final _duckdb_execute_prepared_streaming =
      _duckdb_execute_prepared_streamingPtr.asFunction<
          int Function(
              duckdb_prepared_statement, ffi.Pointer<duckdb_result>)>();

  /// !
  /// Extract all statements from a query.
  /// Note that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using
  /// `duckdb_destroy_extracted`, even if no statements were extracted.
  ///
  /// If the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.
  ///
  /// @param connection The connection object
  /// @param query The SQL query to extract
  /// @param out_extracted_statements The resulting extracted statements object
  /// @return The number of extracted statements or 0 on failure.
  int duckdb_extract_statements(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_extracted_statements> out_extracted_statements,
  ) {
    return _duckdb_extract_statements(
      connection,
      query,
      out_extracted_statements,
    );
  }

  late final _duckdb_extract_statementsPtr = _lookup<
          ffi.NativeFunction<
              idx_t Function(duckdb_connection, ffi.Pointer<ffi.Char>,
                  ffi.Pointer<duckdb_extracted_statements>)>>(
      'duckdb_extract_statements');
  late final _duckdb_extract_statements =
      _duckdb_extract_statementsPtr.asFunction<
          int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_extracted_statements>)>();

  /// !
  /// Prepare an extracted statement.
  /// Note that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using
  /// `duckdb_destroy_prepare`, even if the prepare fails.
  ///
  /// If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
  ///
  /// @param connection The connection object
  /// @param extracted_statements The extracted statements object
  /// @param index The index of the extracted statement to prepare
  /// @param out_prepared_statement The resulting prepared statement object
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_prepare_extracted_statement(
    duckdb_connection connection,
    duckdb_extracted_statements extracted_statements,
    Dartidx_t index,
    ffi.Pointer<duckdb_prepared_statement> out_prepared_statement,
  ) {
    return duckdb_state.fromValue(_duckdb_prepare_extracted_statement(
      connection,
      extracted_statements,
      index,
      out_prepared_statement,
    ));
  }

  late final _duckdb_prepare_extracted_statementPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection,
                  duckdb_extracted_statements,
                  idx_t,
                  ffi.Pointer<duckdb_prepared_statement>)>>(
      'duckdb_prepare_extracted_statement');
  late final _duckdb_prepare_extracted_statement =
      _duckdb_prepare_extracted_statementPtr.asFunction<
          int Function(duckdb_connection, duckdb_extracted_statements, int,
              ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Returns the error message contained within the extracted statements.
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.
  ///
  /// @param extracted_statements The extracted statements to fetch the error from.
  /// @return The error of the extracted statements.
  ffi.Pointer<ffi.Char> duckdb_extract_statements_error(
    duckdb_extracted_statements extracted_statements,
  ) {
    return _duckdb_extract_statements_error(
      extracted_statements,
    );
  }

  late final _duckdb_extract_statements_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_extracted_statements)>>('duckdb_extract_statements_error');
  late final _duckdb_extract_statements_error =
      _duckdb_extract_statements_errorPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(duckdb_extracted_statements)>();

  /// !
  /// De-allocates all memory allocated for the extracted statements.
  /// @param extracted_statements The extracted statements to destroy.
  void duckdb_destroy_extracted(
    ffi.Pointer<duckdb_extracted_statements> extracted_statements,
  ) {
    return _duckdb_destroy_extracted(
      extracted_statements,
    );
  }

  late final _duckdb_destroy_extractedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_extracted_statements>)>>(
      'duckdb_destroy_extracted');
  late final _duckdb_destroy_extracted = _duckdb_destroy_extractedPtr
      .asFunction<void Function(ffi.Pointer<duckdb_extracted_statements>)>();

  /// !
  /// Executes the prepared statement with the given bound parameters, and returns a pending result.
  /// The pending result represents an intermediate structure for a query that is not yet fully executed.
  /// The pending result can be used to incrementally execute a query, returning control to the client between tasks.
  ///
  /// Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
  /// `duckdb_destroy_pending`, even if this function returns DuckDBError.
  ///
  /// @param prepared_statement The prepared statement to execute.
  /// @param out_result The pending query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_pending_prepared(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_pending_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_pending_prepared(
      prepared_statement,
      out_result,
    ));
  }

  late final _duckdb_pending_preparedPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_pending_result>)>>('duckdb_pending_prepared');
  late final _duckdb_pending_prepared = _duckdb_pending_preparedPtr.asFunction<
      int Function(
          duckdb_prepared_statement, ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Executes the prepared statement with the given bound parameters, and returns a pending result.
  /// This pending result will create a streaming duckdb_result when executed.
  /// The pending result represents an intermediate structure for a query that is not yet fully executed.
  ///
  /// Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
  /// `duckdb_destroy_pending`, even if this function returns DuckDBError.
  ///
  /// @param prepared_statement The prepared statement to execute.
  /// @param out_result The pending query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_pending_prepared_streaming(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_pending_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_pending_prepared_streaming(
      prepared_statement,
      out_result,
    ));
  }

  late final _duckdb_pending_prepared_streamingPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(duckdb_prepared_statement,
                  ffi.Pointer<duckdb_pending_result>)>>(
      'duckdb_pending_prepared_streaming');
  late final _duckdb_pending_prepared_streaming =
      _duckdb_pending_prepared_streamingPtr.asFunction<
          int Function(
              duckdb_prepared_statement, ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// Closes the pending result and de-allocates all memory allocated for the result.
  ///
  /// @param pending_result The pending result to destroy.
  void duckdb_destroy_pending(
    ffi.Pointer<duckdb_pending_result> pending_result,
  ) {
    return _duckdb_destroy_pending(
      pending_result,
    );
  }

  late final _duckdb_destroy_pendingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<duckdb_pending_result>)>>('duckdb_destroy_pending');
  late final _duckdb_destroy_pending = _duckdb_destroy_pendingPtr
      .asFunction<void Function(ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// Returns the error message contained within the pending result.
  ///
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.
  ///
  /// @param pending_result The pending result to fetch the error from.
  /// @return The error of the pending result.
  ffi.Pointer<ffi.Char> duckdb_pending_error(
    duckdb_pending_result pending_result,
  ) {
    return _duckdb_pending_error(
      pending_result,
    );
  }

  late final _duckdb_pending_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_pending_result)>>('duckdb_pending_error');
  late final _duckdb_pending_error = _duckdb_pending_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_pending_result)>();

  /// !
  /// Executes a single task within the query, returning whether or not the query is ready.
  ///
  /// If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
  /// If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
  /// If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
  ///
  /// The error message can be obtained by calling duckdb_pending_error on the pending_result.
  ///
  /// @param pending_result The pending result to execute a task within.
  /// @return The state of the pending result after the execution.
  duckdb_pending_state duckdb_pending_execute_task(
    duckdb_pending_result pending_result,
  ) {
    return duckdb_pending_state.fromValue(_duckdb_pending_execute_task(
      pending_result,
    ));
  }

  late final _duckdb_pending_execute_taskPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_pending_result)>>(
      'duckdb_pending_execute_task');
  late final _duckdb_pending_execute_task = _duckdb_pending_execute_taskPtr
      .asFunction<int Function(duckdb_pending_result)>();

  /// !
  /// If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
  /// If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_check_state function should be called again.
  /// If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
  ///
  /// The error message can be obtained by calling duckdb_pending_error on the pending_result.
  ///
  /// @param pending_result The pending result.
  /// @return The state of the pending result.
  duckdb_pending_state duckdb_pending_execute_check_state(
    duckdb_pending_result pending_result,
  ) {
    return duckdb_pending_state.fromValue(_duckdb_pending_execute_check_state(
      pending_result,
    ));
  }

  late final _duckdb_pending_execute_check_statePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_pending_result)>>(
      'duckdb_pending_execute_check_state');
  late final _duckdb_pending_execute_check_state =
      _duckdb_pending_execute_check_statePtr
          .asFunction<int Function(duckdb_pending_result)>();

  /// !
  /// Fully execute a pending query result, returning the final query result.
  ///
  /// If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
  /// Otherwise, all remaining tasks must be executed first.
  ///
  /// Note that the result must be freed with `duckdb_destroy_result`.
  ///
  /// @param pending_result The pending result to execute.
  /// @param out_result The result object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_execute_pending(
    duckdb_pending_result pending_result,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_execute_pending(
      pending_result,
      out_result,
    ));
  }

  late final _duckdb_execute_pendingPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_pending_result,
              ffi.Pointer<duckdb_result>)>>('duckdb_execute_pending');
  late final _duckdb_execute_pending = _duckdb_execute_pendingPtr.asFunction<
      int Function(duckdb_pending_result, ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
  /// DUCKDB_PENDING_RESULT_READY, this function will return true.
  ///
  /// @param pending_state The pending state on which to decide whether to finish execution.
  /// @return Boolean indicating pending execution should be considered finished.
  bool duckdb_pending_execution_is_finished(
    duckdb_pending_state pending_state,
  ) {
    return _duckdb_pending_execution_is_finished(
      pending_state.value,
    );
  }

  late final _duckdb_pending_execution_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'duckdb_pending_execution_is_finished');
  late final _duckdb_pending_execution_is_finished =
      _duckdb_pending_execution_is_finishedPtr.asFunction<bool Function(int)>();

  /// !
  /// Destroys the value and de-allocates all memory allocated for that type.
  ///
  /// @param value The value to destroy.
  void duckdb_destroy_value(
    ffi.Pointer<duckdb_value> value,
  ) {
    return _duckdb_destroy_value(
      value,
    );
  }

  late final _duckdb_destroy_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_value>)>>(
          'duckdb_destroy_value');
  late final _duckdb_destroy_value = _duckdb_destroy_valuePtr
      .asFunction<void Function(ffi.Pointer<duckdb_value>)>();

  /// !
  /// Creates a value from a null-terminated string
  ///
  /// @param text The null-terminated string
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_varchar(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _duckdb_create_varchar(
      text,
    );
  }

  late final _duckdb_create_varcharPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Pointer<ffi.Char>)>>(
          'duckdb_create_varchar');
  late final _duckdb_create_varchar = _duckdb_create_varcharPtr
      .asFunction<duckdb_value Function(ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates a value from a string
  ///
  /// @param text The text
  /// @param length The length of the text
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_varchar_length(
    ffi.Pointer<ffi.Char> text,
    int length,
  ) {
    return _duckdb_create_varchar_length(
      text,
      length,
    );
  }

  late final _duckdb_create_varchar_lengthPtr = _lookup<
          ffi
          .NativeFunction<duckdb_value Function(ffi.Pointer<ffi.Char>, idx_t)>>(
      'duckdb_create_varchar_length');
  late final _duckdb_create_varchar_length = _duckdb_create_varchar_lengthPtr
      .asFunction<duckdb_value Function(ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Creates a value from a boolean
  ///
  /// @param input The boolean value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_bool(
    bool input,
  ) {
    return _duckdb_create_bool(
      input,
    );
  }

  late final _duckdb_create_boolPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Bool)>>(
          'duckdb_create_bool');
  late final _duckdb_create_bool =
      _duckdb_create_boolPtr.asFunction<duckdb_value Function(bool)>();

  /// !
  /// Creates a value from a int8_t (a tinyint)
  ///
  /// @param input The tinyint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_int8(
    int input,
  ) {
    return _duckdb_create_int8(
      input,
    );
  }

  late final _duckdb_create_int8Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Int8)>>(
          'duckdb_create_int8');
  late final _duckdb_create_int8 =
      _duckdb_create_int8Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a uint8_t (a utinyint)
  ///
  /// @param input The utinyint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uint8(
    int input,
  ) {
    return _duckdb_create_uint8(
      input,
    );
  }

  late final _duckdb_create_uint8Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Uint8)>>(
          'duckdb_create_uint8');
  late final _duckdb_create_uint8 =
      _duckdb_create_uint8Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a int16_t (a smallint)
  ///
  /// @param input The smallint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_int16(
    int input,
  ) {
    return _duckdb_create_int16(
      input,
    );
  }

  late final _duckdb_create_int16Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Int16)>>(
          'duckdb_create_int16');
  late final _duckdb_create_int16 =
      _duckdb_create_int16Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a uint16_t (a usmallint)
  ///
  /// @param input The usmallint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uint16(
    int input,
  ) {
    return _duckdb_create_uint16(
      input,
    );
  }

  late final _duckdb_create_uint16Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Uint16)>>(
          'duckdb_create_uint16');
  late final _duckdb_create_uint16 =
      _duckdb_create_uint16Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a int32_t (an integer)
  ///
  /// @param input The integer value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_int32(
    int input,
  ) {
    return _duckdb_create_int32(
      input,
    );
  }

  late final _duckdb_create_int32Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Int32)>>(
          'duckdb_create_int32');
  late final _duckdb_create_int32 =
      _duckdb_create_int32Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a uint32_t (a uinteger)
  ///
  /// @param input The uinteger value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uint32(
    int input,
  ) {
    return _duckdb_create_uint32(
      input,
    );
  }

  late final _duckdb_create_uint32Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Uint32)>>(
          'duckdb_create_uint32');
  late final _duckdb_create_uint32 =
      _duckdb_create_uint32Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a uint64_t (a ubigint)
  ///
  /// @param input The ubigint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uint64(
    int input,
  ) {
    return _duckdb_create_uint64(
      input,
    );
  }

  late final _duckdb_create_uint64Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Uint64)>>(
          'duckdb_create_uint64');
  late final _duckdb_create_uint64 =
      _duckdb_create_uint64Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from an int64
  ///
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_int64(
    int val,
  ) {
    return _duckdb_create_int64(
      val,
    );
  }

  late final _duckdb_create_int64Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Int64)>>(
          'duckdb_create_int64');
  late final _duckdb_create_int64 =
      _duckdb_create_int64Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Creates a value from a hugeint
  ///
  /// @param input The hugeint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_hugeint(
    duckdb_hugeint input,
  ) {
    return _duckdb_create_hugeint(
      input,
    );
  }

  late final _duckdb_create_hugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_hugeint)>>(
          'duckdb_create_hugeint');
  late final _duckdb_create_hugeint = _duckdb_create_hugeintPtr
      .asFunction<duckdb_value Function(duckdb_hugeint)>();

  /// !
  /// Creates a value from a uhugeint
  ///
  /// @param input The uhugeint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uhugeint(
    duckdb_uhugeint input,
  ) {
    return _duckdb_create_uhugeint(
      input,
    );
  }

  late final _duckdb_create_uhugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_uhugeint)>>(
          'duckdb_create_uhugeint');
  late final _duckdb_create_uhugeint = _duckdb_create_uhugeintPtr
      .asFunction<duckdb_value Function(duckdb_uhugeint)>();

  /// !
  /// Creates a VARINT value from a duckdb_varint
  ///
  /// @param input The duckdb_varint value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_varint(
    duckdb_varint input,
  ) {
    return _duckdb_create_varint(
      input,
    );
  }

  late final _duckdb_create_varintPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_varint)>>(
          'duckdb_create_varint');
  late final _duckdb_create_varint = _duckdb_create_varintPtr
      .asFunction<duckdb_value Function(duckdb_varint)>();

  /// !
  /// Creates a DECIMAL value from a duckdb_decimal
  ///
  /// @param input The duckdb_decimal value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_decimal(
    duckdb_decimal input,
  ) {
    return _duckdb_create_decimal(
      input,
    );
  }

  late final _duckdb_create_decimalPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_decimal)>>(
          'duckdb_create_decimal');
  late final _duckdb_create_decimal = _duckdb_create_decimalPtr
      .asFunction<duckdb_value Function(duckdb_decimal)>();

  /// !
  /// Creates a value from a float
  ///
  /// @param input The float value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_float(
    double input,
  ) {
    return _duckdb_create_float(
      input,
    );
  }

  late final _duckdb_create_floatPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Float)>>(
          'duckdb_create_float');
  late final _duckdb_create_float =
      _duckdb_create_floatPtr.asFunction<duckdb_value Function(double)>();

  /// !
  /// Creates a value from a double
  ///
  /// @param input The double value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_double(
    double input,
  ) {
    return _duckdb_create_double(
      input,
    );
  }

  late final _duckdb_create_doublePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Double)>>(
          'duckdb_create_double');
  late final _duckdb_create_double =
      _duckdb_create_doublePtr.asFunction<duckdb_value Function(double)>();

  /// !
  /// Creates a value from a date
  ///
  /// @param input The date value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_date(
    duckdb_date input,
  ) {
    return _duckdb_create_date(
      input,
    );
  }

  late final _duckdb_create_datePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_date)>>(
          'duckdb_create_date');
  late final _duckdb_create_date =
      _duckdb_create_datePtr.asFunction<duckdb_value Function(duckdb_date)>();

  /// !
  /// Creates a value from a time
  ///
  /// @param input The time value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_time(
    duckdb_time input,
  ) {
    return _duckdb_create_time(
      input,
    );
  }

  late final _duckdb_create_timePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_time)>>(
          'duckdb_create_time');
  late final _duckdb_create_time =
      _duckdb_create_timePtr.asFunction<duckdb_value Function(duckdb_time)>();

  /// !
  /// Creates a value from a time_tz.
  /// Not to be confused with `duckdb_create_time_tz`, which creates a duckdb_time_tz_t.
  ///
  /// @param value The time_tz value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_time_tz_value(
    duckdb_time_tz value,
  ) {
    return _duckdb_create_time_tz_value(
      value,
    );
  }

  late final _duckdb_create_time_tz_valuePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_time_tz)>>(
          'duckdb_create_time_tz_value');
  late final _duckdb_create_time_tz_value = _duckdb_create_time_tz_valuePtr
      .asFunction<duckdb_value Function(duckdb_time_tz)>();

  /// !
  /// Creates a TIMESTAMP value from a duckdb_timestamp
  ///
  /// @param input The duckdb_timestamp value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_timestamp(
    duckdb_timestamp input,
  ) {
    return _duckdb_create_timestamp(
      input,
    );
  }

  late final _duckdb_create_timestampPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_timestamp)>>(
          'duckdb_create_timestamp');
  late final _duckdb_create_timestamp = _duckdb_create_timestampPtr
      .asFunction<duckdb_value Function(duckdb_timestamp)>();

  /// !
  /// Creates a TIMESTAMP_TZ value from a duckdb_timestamp
  ///
  /// @param input The duckdb_timestamp value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_timestamp_tz(
    duckdb_timestamp input,
  ) {
    return _duckdb_create_timestamp_tz(
      input,
    );
  }

  late final _duckdb_create_timestamp_tzPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_timestamp)>>(
          'duckdb_create_timestamp_tz');
  late final _duckdb_create_timestamp_tz = _duckdb_create_timestamp_tzPtr
      .asFunction<duckdb_value Function(duckdb_timestamp)>();

  /// !
  /// Creates a TIMESTAMP_S value from a duckdb_timestamp_s
  ///
  /// @param input The duckdb_timestamp_s value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_timestamp_s(
    duckdb_timestamp_s input,
  ) {
    return _duckdb_create_timestamp_s(
      input,
    );
  }

  late final _duckdb_create_timestamp_sPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_timestamp_s)>>(
          'duckdb_create_timestamp_s');
  late final _duckdb_create_timestamp_s = _duckdb_create_timestamp_sPtr
      .asFunction<duckdb_value Function(duckdb_timestamp_s)>();

  /// !
  /// Creates a TIMESTAMP_MS value from a duckdb_timestamp_ms
  ///
  /// @param input The duckdb_timestamp_ms value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_timestamp_ms(
    duckdb_timestamp_ms input,
  ) {
    return _duckdb_create_timestamp_ms(
      input,
    );
  }

  late final _duckdb_create_timestamp_msPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_timestamp_ms)>>(
          'duckdb_create_timestamp_ms');
  late final _duckdb_create_timestamp_ms = _duckdb_create_timestamp_msPtr
      .asFunction<duckdb_value Function(duckdb_timestamp_ms)>();

  /// !
  /// Creates a TIMESTAMP_NS value from a duckdb_timestamp_ns
  ///
  /// @param input The duckdb_timestamp_ns value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_timestamp_ns(
    duckdb_timestamp_ns input,
  ) {
    return _duckdb_create_timestamp_ns(
      input,
    );
  }

  late final _duckdb_create_timestamp_nsPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_timestamp_ns)>>(
          'duckdb_create_timestamp_ns');
  late final _duckdb_create_timestamp_ns = _duckdb_create_timestamp_nsPtr
      .asFunction<duckdb_value Function(duckdb_timestamp_ns)>();

  /// !
  /// Creates a value from an interval
  ///
  /// @param input The interval value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_interval(
    duckdb_interval input,
  ) {
    return _duckdb_create_interval(
      input,
    );
  }

  late final _duckdb_create_intervalPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_interval)>>(
          'duckdb_create_interval');
  late final _duckdb_create_interval = _duckdb_create_intervalPtr
      .asFunction<duckdb_value Function(duckdb_interval)>();

  /// !
  /// Creates a value from a blob
  ///
  /// @param data The blob data
  /// @param length The length of the blob data
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_blob(
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _duckdb_create_blob(
      data,
      length,
    );
  }

  late final _duckdb_create_blobPtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(
              ffi.Pointer<ffi.Uint8>, idx_t)>>('duckdb_create_blob');
  late final _duckdb_create_blob = _duckdb_create_blobPtr
      .asFunction<duckdb_value Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// !
  /// Creates a BIT value from a duckdb_bit
  ///
  /// @param input The duckdb_bit value
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_bit(
    duckdb_bit input,
  ) {
    return _duckdb_create_bit(
      input,
    );
  }

  late final _duckdb_create_bitPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_bit)>>(
          'duckdb_create_bit');
  late final _duckdb_create_bit =
      _duckdb_create_bitPtr.asFunction<duckdb_value Function(duckdb_bit)>();

  /// !
  /// Creates a UUID value from a uhugeint
  ///
  /// @param input The duckdb_uhugeint containing the UUID
  /// @return The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_uuid(
    duckdb_uhugeint input,
  ) {
    return _duckdb_create_uuid(
      input,
    );
  }

  late final _duckdb_create_uuidPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_uhugeint)>>(
          'duckdb_create_uuid');
  late final _duckdb_create_uuid = _duckdb_create_uuidPtr
      .asFunction<duckdb_value Function(duckdb_uhugeint)>();

  /// !
  /// Returns the boolean value of the given value.
  ///
  /// @param val A duckdb_value containing a boolean
  /// @return A boolean, or false if the value cannot be converted
  bool duckdb_get_bool(
    duckdb_value val,
  ) {
    return _duckdb_get_bool(
      val,
    );
  }

  late final _duckdb_get_boolPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_value)>>(
          'duckdb_get_bool');
  late final _duckdb_get_bool =
      _duckdb_get_boolPtr.asFunction<bool Function(duckdb_value)>();

  /// !
  /// Returns the int8_t value of the given value.
  ///
  /// @param val A duckdb_value containing a tinyint
  /// @return A int8_t, or MinValue<int8> if the value cannot be converted
  int duckdb_get_int8(
    duckdb_value val,
  ) {
    return _duckdb_get_int8(
      val,
    );
  }

  late final _duckdb_get_int8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int8 Function(duckdb_value)>>(
          'duckdb_get_int8');
  late final _duckdb_get_int8 =
      _duckdb_get_int8Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the uint8_t value of the given value.
  ///
  /// @param val A duckdb_value containing a utinyint
  /// @return A uint8_t, or MinValue<uint8> if the value cannot be converted
  int duckdb_get_uint8(
    duckdb_value val,
  ) {
    return _duckdb_get_uint8(
      val,
    );
  }

  late final _duckdb_get_uint8Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(duckdb_value)>>(
          'duckdb_get_uint8');
  late final _duckdb_get_uint8 =
      _duckdb_get_uint8Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the int16_t value of the given value.
  ///
  /// @param val A duckdb_value containing a smallint
  /// @return A int16_t, or MinValue<int16> if the value cannot be converted
  int duckdb_get_int16(
    duckdb_value val,
  ) {
    return _duckdb_get_int16(
      val,
    );
  }

  late final _duckdb_get_int16Ptr =
      _lookup<ffi.NativeFunction<ffi.Int16 Function(duckdb_value)>>(
          'duckdb_get_int16');
  late final _duckdb_get_int16 =
      _duckdb_get_int16Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the uint16_t value of the given value.
  ///
  /// @param val A duckdb_value containing a usmallint
  /// @return A uint16_t, or MinValue<uint16> if the value cannot be converted
  int duckdb_get_uint16(
    duckdb_value val,
  ) {
    return _duckdb_get_uint16(
      val,
    );
  }

  late final _duckdb_get_uint16Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(duckdb_value)>>(
          'duckdb_get_uint16');
  late final _duckdb_get_uint16 =
      _duckdb_get_uint16Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the int32_t value of the given value.
  ///
  /// @param val A duckdb_value containing a integer
  /// @return A int32_t, or MinValue<int32> if the value cannot be converted
  int duckdb_get_int32(
    duckdb_value val,
  ) {
    return _duckdb_get_int32(
      val,
    );
  }

  late final _duckdb_get_int32Ptr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_value)>>(
          'duckdb_get_int32');
  late final _duckdb_get_int32 =
      _duckdb_get_int32Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the uint32_t value of the given value.
  ///
  /// @param val A duckdb_value containing a uinteger
  /// @return A uint32_t, or MinValue<uint32> if the value cannot be converted
  int duckdb_get_uint32(
    duckdb_value val,
  ) {
    return _duckdb_get_uint32(
      val,
    );
  }

  late final _duckdb_get_uint32Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(duckdb_value)>>(
          'duckdb_get_uint32');
  late final _duckdb_get_uint32 =
      _duckdb_get_uint32Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the int64_t value of the given value.
  ///
  /// @param val A duckdb_value containing a bigint
  /// @return A int64_t, or MinValue<int64> if the value cannot be converted
  int duckdb_get_int64(
    duckdb_value val,
  ) {
    return _duckdb_get_int64(
      val,
    );
  }

  late final _duckdb_get_int64Ptr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(duckdb_value)>>(
          'duckdb_get_int64');
  late final _duckdb_get_int64 =
      _duckdb_get_int64Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the uint64_t value of the given value.
  ///
  /// @param val A duckdb_value containing a ubigint
  /// @return A uint64_t, or MinValue<uint64> if the value cannot be converted
  int duckdb_get_uint64(
    duckdb_value val,
  ) {
    return _duckdb_get_uint64(
      val,
    );
  }

  late final _duckdb_get_uint64Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(duckdb_value)>>(
          'duckdb_get_uint64');
  late final _duckdb_get_uint64 =
      _duckdb_get_uint64Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the hugeint value of the given value.
  ///
  /// @param val A duckdb_value containing a hugeint
  /// @return A duckdb_hugeint, or MinValue<hugeint> if the value cannot be converted
  duckdb_hugeint duckdb_get_hugeint(
    duckdb_value val,
  ) {
    return _duckdb_get_hugeint(
      val,
    );
  }

  late final _duckdb_get_hugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_hugeint Function(duckdb_value)>>(
          'duckdb_get_hugeint');
  late final _duckdb_get_hugeint = _duckdb_get_hugeintPtr
      .asFunction<duckdb_hugeint Function(duckdb_value)>();

  /// !
  /// Returns the uhugeint value of the given value.
  ///
  /// @param val A duckdb_value containing a uhugeint
  /// @return A duckdb_uhugeint, or MinValue<uhugeint> if the value cannot be converted
  duckdb_uhugeint duckdb_get_uhugeint(
    duckdb_value val,
  ) {
    return _duckdb_get_uhugeint(
      val,
    );
  }

  late final _duckdb_get_uhugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_uhugeint Function(duckdb_value)>>(
          'duckdb_get_uhugeint');
  late final _duckdb_get_uhugeint = _duckdb_get_uhugeintPtr
      .asFunction<duckdb_uhugeint Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_varint value of the given value.
  /// The `data` field must be destroyed with `duckdb_free`.
  ///
  /// @param val A duckdb_value containing a VARINT
  /// @return A duckdb_varint. The `data` field must be destroyed with `duckdb_free`.
  duckdb_varint duckdb_get_varint(
    duckdb_value val,
  ) {
    return _duckdb_get_varint(
      val,
    );
  }

  late final _duckdb_get_varintPtr =
      _lookup<ffi.NativeFunction<duckdb_varint Function(duckdb_value)>>(
          'duckdb_get_varint');
  late final _duckdb_get_varint =
      _duckdb_get_varintPtr.asFunction<duckdb_varint Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_decimal value of the given value.
  ///
  /// @param val A duckdb_value containing a DECIMAL
  /// @return A duckdb_decimal, or MinValue<decimal> if the value cannot be converted
  duckdb_decimal duckdb_get_decimal(
    duckdb_value val,
  ) {
    return _duckdb_get_decimal(
      val,
    );
  }

  late final _duckdb_get_decimalPtr =
      _lookup<ffi.NativeFunction<duckdb_decimal Function(duckdb_value)>>(
          'duckdb_get_decimal');
  late final _duckdb_get_decimal = _duckdb_get_decimalPtr
      .asFunction<duckdb_decimal Function(duckdb_value)>();

  /// !
  /// Returns the float value of the given value.
  ///
  /// @param val A duckdb_value containing a float
  /// @return A float, or NAN if the value cannot be converted
  double duckdb_get_float(
    duckdb_value val,
  ) {
    return _duckdb_get_float(
      val,
    );
  }

  late final _duckdb_get_floatPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(duckdb_value)>>(
          'duckdb_get_float');
  late final _duckdb_get_float =
      _duckdb_get_floatPtr.asFunction<double Function(duckdb_value)>();

  /// !
  /// Returns the double value of the given value.
  ///
  /// @param val A duckdb_value containing a double
  /// @return A double, or NAN if the value cannot be converted
  double duckdb_get_double(
    duckdb_value val,
  ) {
    return _duckdb_get_double(
      val,
    );
  }

  late final _duckdb_get_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_value)>>(
          'duckdb_get_double');
  late final _duckdb_get_double =
      _duckdb_get_doublePtr.asFunction<double Function(duckdb_value)>();

  /// !
  /// Returns the date value of the given value.
  ///
  /// @param val A duckdb_value containing a date
  /// @return A duckdb_date, or MinValue<date> if the value cannot be converted
  duckdb_date duckdb_get_date(
    duckdb_value val,
  ) {
    return _duckdb_get_date(
      val,
    );
  }

  late final _duckdb_get_datePtr =
      _lookup<ffi.NativeFunction<duckdb_date Function(duckdb_value)>>(
          'duckdb_get_date');
  late final _duckdb_get_date =
      _duckdb_get_datePtr.asFunction<duckdb_date Function(duckdb_value)>();

  /// !
  /// Returns the time value of the given value.
  ///
  /// @param val A duckdb_value containing a time
  /// @return A duckdb_time, or MinValue<time> if the value cannot be converted
  duckdb_time duckdb_get_time(
    duckdb_value val,
  ) {
    return _duckdb_get_time(
      val,
    );
  }

  late final _duckdb_get_timePtr =
      _lookup<ffi.NativeFunction<duckdb_time Function(duckdb_value)>>(
          'duckdb_get_time');
  late final _duckdb_get_time =
      _duckdb_get_timePtr.asFunction<duckdb_time Function(duckdb_value)>();

  /// !
  /// Returns the time_tz value of the given value.
  ///
  /// @param val A duckdb_value containing a time_tz
  /// @return A duckdb_time_tz, or MinValue<time_tz> if the value cannot be converted
  duckdb_time_tz duckdb_get_time_tz(
    duckdb_value val,
  ) {
    return _duckdb_get_time_tz(
      val,
    );
  }

  late final _duckdb_get_time_tzPtr =
      _lookup<ffi.NativeFunction<duckdb_time_tz Function(duckdb_value)>>(
          'duckdb_get_time_tz');
  late final _duckdb_get_time_tz = _duckdb_get_time_tzPtr
      .asFunction<duckdb_time_tz Function(duckdb_value)>();

  /// !
  /// Returns the TIMESTAMP value of the given value.
  ///
  /// @param val A duckdb_value containing a TIMESTAMP
  /// @return A duckdb_timestamp, or MinValue<timestamp> if the value cannot be converted
  duckdb_timestamp duckdb_get_timestamp(
    duckdb_value val,
  ) {
    return _duckdb_get_timestamp(
      val,
    );
  }

  late final _duckdb_get_timestampPtr =
      _lookup<ffi.NativeFunction<duckdb_timestamp Function(duckdb_value)>>(
          'duckdb_get_timestamp');
  late final _duckdb_get_timestamp = _duckdb_get_timestampPtr
      .asFunction<duckdb_timestamp Function(duckdb_value)>();

  /// !
  /// Returns the TIMESTAMP_TZ value of the given value.
  ///
  /// @param val A duckdb_value containing a TIMESTAMP_TZ
  /// @return A duckdb_timestamp, or MinValue<timestamp_tz> if the value cannot be converted
  duckdb_timestamp duckdb_get_timestamp_tz(
    duckdb_value val,
  ) {
    return _duckdb_get_timestamp_tz(
      val,
    );
  }

  late final _duckdb_get_timestamp_tzPtr =
      _lookup<ffi.NativeFunction<duckdb_timestamp Function(duckdb_value)>>(
          'duckdb_get_timestamp_tz');
  late final _duckdb_get_timestamp_tz = _duckdb_get_timestamp_tzPtr
      .asFunction<duckdb_timestamp Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_timestamp_s value of the given value.
  ///
  /// @param val A duckdb_value containing a TIMESTAMP_S
  /// @return A duckdb_timestamp_s, or MinValue<timestamp_s> if the value cannot be converted
  duckdb_timestamp_s duckdb_get_timestamp_s(
    duckdb_value val,
  ) {
    return _duckdb_get_timestamp_s(
      val,
    );
  }

  late final _duckdb_get_timestamp_sPtr =
      _lookup<ffi.NativeFunction<duckdb_timestamp_s Function(duckdb_value)>>(
          'duckdb_get_timestamp_s');
  late final _duckdb_get_timestamp_s = _duckdb_get_timestamp_sPtr
      .asFunction<duckdb_timestamp_s Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_timestamp_ms value of the given value.
  ///
  /// @param val A duckdb_value containing a TIMESTAMP_MS
  /// @return A duckdb_timestamp_ms, or MinValue<timestamp_ms> if the value cannot be converted
  duckdb_timestamp_ms duckdb_get_timestamp_ms(
    duckdb_value val,
  ) {
    return _duckdb_get_timestamp_ms(
      val,
    );
  }

  late final _duckdb_get_timestamp_msPtr =
      _lookup<ffi.NativeFunction<duckdb_timestamp_ms Function(duckdb_value)>>(
          'duckdb_get_timestamp_ms');
  late final _duckdb_get_timestamp_ms = _duckdb_get_timestamp_msPtr
      .asFunction<duckdb_timestamp_ms Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_timestamp_ns value of the given value.
  ///
  /// @param val A duckdb_value containing a TIMESTAMP_NS
  /// @return A duckdb_timestamp_ns, or MinValue<timestamp_ns> if the value cannot be converted
  duckdb_timestamp_ns duckdb_get_timestamp_ns(
    duckdb_value val,
  ) {
    return _duckdb_get_timestamp_ns(
      val,
    );
  }

  late final _duckdb_get_timestamp_nsPtr =
      _lookup<ffi.NativeFunction<duckdb_timestamp_ns Function(duckdb_value)>>(
          'duckdb_get_timestamp_ns');
  late final _duckdb_get_timestamp_ns = _duckdb_get_timestamp_nsPtr
      .asFunction<duckdb_timestamp_ns Function(duckdb_value)>();

  /// !
  /// Returns the interval value of the given value.
  ///
  /// @param val A duckdb_value containing a interval
  /// @return A duckdb_interval, or MinValue<interval> if the value cannot be converted
  duckdb_interval duckdb_get_interval(
    duckdb_value val,
  ) {
    return _duckdb_get_interval(
      val,
    );
  }

  late final _duckdb_get_intervalPtr =
      _lookup<ffi.NativeFunction<duckdb_interval Function(duckdb_value)>>(
          'duckdb_get_interval');
  late final _duckdb_get_interval = _duckdb_get_intervalPtr
      .asFunction<duckdb_interval Function(duckdb_value)>();

  /// !
  /// Returns the type of the given value. The type is valid as long as the value is not destroyed.
  /// The type itself must not be destroyed.
  ///
  /// @param val A duckdb_value
  /// @return A duckdb_logical_type.
  duckdb_logical_type duckdb_get_value_type(
    duckdb_value val,
  ) {
    return _duckdb_get_value_type(
      val,
    );
  }

  late final _duckdb_get_value_typePtr =
      _lookup<ffi.NativeFunction<duckdb_logical_type Function(duckdb_value)>>(
          'duckdb_get_value_type');
  late final _duckdb_get_value_type = _duckdb_get_value_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_value)>();

  /// !
  /// Returns the blob value of the given value.
  ///
  /// @param val A duckdb_value containing a blob
  /// @return A duckdb_blob
  duckdb_blob duckdb_get_blob(
    duckdb_value val,
  ) {
    return _duckdb_get_blob(
      val,
    );
  }

  late final _duckdb_get_blobPtr =
      _lookup<ffi.NativeFunction<duckdb_blob Function(duckdb_value)>>(
          'duckdb_get_blob');
  late final _duckdb_get_blob =
      _duckdb_get_blobPtr.asFunction<duckdb_blob Function(duckdb_value)>();

  /// !
  /// Returns the duckdb_bit value of the given value.
  /// The `data` field must be destroyed with `duckdb_free`.
  ///
  /// @param val A duckdb_value containing a BIT
  /// @return A duckdb_bit
  duckdb_bit duckdb_get_bit(
    duckdb_value val,
  ) {
    return _duckdb_get_bit(
      val,
    );
  }

  late final _duckdb_get_bitPtr =
      _lookup<ffi.NativeFunction<duckdb_bit Function(duckdb_value)>>(
          'duckdb_get_bit');
  late final _duckdb_get_bit =
      _duckdb_get_bitPtr.asFunction<duckdb_bit Function(duckdb_value)>();

  /// !
  /// Returns a duckdb_uhugeint representing the UUID value of the given value.
  ///
  /// @param val A duckdb_value containing a UUID
  /// @return A duckdb_uhugeint representing the UUID value
  duckdb_uhugeint duckdb_get_uuid(
    duckdb_value val,
  ) {
    return _duckdb_get_uuid(
      val,
    );
  }

  late final _duckdb_get_uuidPtr =
      _lookup<ffi.NativeFunction<duckdb_uhugeint Function(duckdb_value)>>(
          'duckdb_get_uuid');
  late final _duckdb_get_uuid =
      _duckdb_get_uuidPtr.asFunction<duckdb_uhugeint Function(duckdb_value)>();

  /// !
  /// Obtains a string representation of the given value.
  /// The result must be destroyed with `duckdb_free`.
  ///
  /// @param value The value
  /// @return The string value. This must be destroyed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_get_varchar(
    duckdb_value value,
  ) {
    return _duckdb_get_varchar(
      value,
    );
  }

  late final _duckdb_get_varcharPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_value)>>(
          'duckdb_get_varchar');
  late final _duckdb_get_varchar = _duckdb_get_varcharPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_value)>();

  /// !
  /// Creates a struct value from a type and an array of values. Must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param type The type of the struct
  /// @param values The values for the struct fields
  /// @return The struct value, or nullptr, if any child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
  duckdb_value duckdb_create_struct_value(
    duckdb_logical_type type,
    ffi.Pointer<duckdb_value> values,
  ) {
    return _duckdb_create_struct_value(
      type,
      values,
    );
  }

  late final _duckdb_create_struct_valuePtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_logical_type,
              ffi.Pointer<duckdb_value>)>>('duckdb_create_struct_value');
  late final _duckdb_create_struct_value =
      _duckdb_create_struct_valuePtr.asFunction<
          duckdb_value Function(
              duckdb_logical_type, ffi.Pointer<duckdb_value>)>();

  /// !
  /// Creates a list value from a child (element) type and an array of values of length `value_count`.
  /// Must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param type The type of the list
  /// @param values The values for the list
  /// @param value_count The number of values in the list
  /// @return The list value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
  duckdb_value duckdb_create_list_value(
    duckdb_logical_type type,
    ffi.Pointer<duckdb_value> values,
    int value_count,
  ) {
    return _duckdb_create_list_value(
      type,
      values,
      value_count,
    );
  }

  late final _duckdb_create_list_valuePtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_logical_type, ffi.Pointer<duckdb_value>,
              idx_t)>>('duckdb_create_list_value');
  late final _duckdb_create_list_value =
      _duckdb_create_list_valuePtr.asFunction<
          duckdb_value Function(
              duckdb_logical_type, ffi.Pointer<duckdb_value>, int)>();

  /// !
  /// Creates an array value from a child (element) type and an array of values of length `value_count`.
  /// Must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param type The type of the array
  /// @param values The values for the array
  /// @param value_count The number of values in the array
  /// @return The array value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
  duckdb_value duckdb_create_array_value(
    duckdb_logical_type type,
    ffi.Pointer<duckdb_value> values,
    int value_count,
  ) {
    return _duckdb_create_array_value(
      type,
      values,
      value_count,
    );
  }

  late final _duckdb_create_array_valuePtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_logical_type, ffi.Pointer<duckdb_value>,
              idx_t)>>('duckdb_create_array_value');
  late final _duckdb_create_array_value =
      _duckdb_create_array_valuePtr.asFunction<
          duckdb_value Function(
              duckdb_logical_type, ffi.Pointer<duckdb_value>, int)>();

  /// !
  /// Returns the number of elements in a MAP value.
  ///
  /// @param value The MAP value.
  /// @return The number of elements in the map.
  int duckdb_get_map_size(
    duckdb_value value,
  ) {
    return _duckdb_get_map_size(
      value,
    );
  }

  late final _duckdb_get_map_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_value)>>(
          'duckdb_get_map_size');
  late final _duckdb_get_map_size =
      _duckdb_get_map_sizePtr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the MAP key at index as a duckdb_value.
  ///
  /// @param value The MAP value.
  /// @param index The index of the key.
  /// @return The key as a duckdb_value.
  duckdb_value duckdb_get_map_key(
    duckdb_value value,
    int index,
  ) {
    return _duckdb_get_map_key(
      value,
      index,
    );
  }

  late final _duckdb_get_map_keyPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_value, idx_t)>>(
          'duckdb_get_map_key');
  late final _duckdb_get_map_key = _duckdb_get_map_keyPtr
      .asFunction<duckdb_value Function(duckdb_value, int)>();

  /// !
  /// Returns the MAP value at index as a duckdb_value.
  ///
  /// @param value The MAP value.
  /// @param index The index of the value.
  /// @return The value as a duckdb_value.
  duckdb_value duckdb_get_map_value(
    duckdb_value value,
    int index,
  ) {
    return _duckdb_get_map_value(
      value,
      index,
    );
  }

  late final _duckdb_get_map_valuePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_value, idx_t)>>(
          'duckdb_get_map_value');
  late final _duckdb_get_map_value = _duckdb_get_map_valuePtr
      .asFunction<duckdb_value Function(duckdb_value, int)>();

  /// !
  /// Returns whether the value's type is SQLNULL or not.
  ///
  /// @param value The value to check.
  /// @return True, if the value's type is SQLNULL, otherwise false.
  bool duckdb_is_null_value(
    duckdb_value value,
  ) {
    return _duckdb_is_null_value(
      value,
    );
  }

  late final _duckdb_is_null_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_value)>>(
          'duckdb_is_null_value');
  late final _duckdb_is_null_value =
      _duckdb_is_null_valuePtr.asFunction<bool Function(duckdb_value)>();

  /// !
  /// Creates a value of type SQLNULL.
  ///
  /// @return The duckdb_value representing SQLNULL. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_null_value() {
    return _duckdb_create_null_value();
  }

  late final _duckdb_create_null_valuePtr =
      _lookup<ffi.NativeFunction<duckdb_value Function()>>(
          'duckdb_create_null_value');
  late final _duckdb_create_null_value =
      _duckdb_create_null_valuePtr.asFunction<duckdb_value Function()>();

  /// !
  /// Returns the number of elements in a LIST value.
  ///
  /// @param value The LIST value.
  /// @return The number of elements in the list.
  int duckdb_get_list_size(
    duckdb_value value,
  ) {
    return _duckdb_get_list_size(
      value,
    );
  }

  late final _duckdb_get_list_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_value)>>(
          'duckdb_get_list_size');
  late final _duckdb_get_list_size =
      _duckdb_get_list_sizePtr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the LIST child at index as a duckdb_value.
  ///
  /// @param value The LIST value.
  /// @param index The index of the child.
  /// @return The child as a duckdb_value.
  duckdb_value duckdb_get_list_child(
    duckdb_value value,
    int index,
  ) {
    return _duckdb_get_list_child(
      value,
      index,
    );
  }

  late final _duckdb_get_list_childPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_value, idx_t)>>(
          'duckdb_get_list_child');
  late final _duckdb_get_list_child = _duckdb_get_list_childPtr
      .asFunction<duckdb_value Function(duckdb_value, int)>();

  /// !
  /// Creates an enum value from a type and a value. Must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param type The type of the enum
  /// @param value The value for the enum
  /// @return The enum value, or nullptr.
  duckdb_value duckdb_create_enum_value(
    duckdb_logical_type type,
    int value,
  ) {
    return _duckdb_create_enum_value(
      type,
      value,
    );
  }

  late final _duckdb_create_enum_valuePtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(
              duckdb_logical_type, ffi.Uint64)>>('duckdb_create_enum_value');
  late final _duckdb_create_enum_value = _duckdb_create_enum_valuePtr
      .asFunction<duckdb_value Function(duckdb_logical_type, int)>();

  /// !
  /// Returns the enum value of the given value.
  ///
  /// @param value A duckdb_value containing an enum
  /// @return A uint64_t, or MinValue<uint64> if the value cannot be converted
  int duckdb_get_enum_value(
    duckdb_value value,
  ) {
    return _duckdb_get_enum_value(
      value,
    );
  }

  late final _duckdb_get_enum_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(duckdb_value)>>(
          'duckdb_get_enum_value');
  late final _duckdb_get_enum_value =
      _duckdb_get_enum_valuePtr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Returns the STRUCT child at index as a duckdb_value.
  ///
  /// @param value The STRUCT value.
  /// @param index The index of the child.
  /// @return The child as a duckdb_value.
  duckdb_value duckdb_get_struct_child(
    duckdb_value value,
    int index,
  ) {
    return _duckdb_get_struct_child(
      value,
      index,
    );
  }

  late final _duckdb_get_struct_childPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_value, idx_t)>>(
          'duckdb_get_struct_child');
  late final _duckdb_get_struct_child = _duckdb_get_struct_childPtr
      .asFunction<duckdb_value Function(duckdb_value, int)>();

  /// !
  /// Creates a `duckdb_logical_type` from a primitive type.
  /// The resulting logical type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// Returns an invalid logical type, if type is: `DUCKDB_TYPE_INVALID`, `DUCKDB_TYPE_DECIMAL`, `DUCKDB_TYPE_ENUM`,
  /// `DUCKDB_TYPE_LIST`, `DUCKDB_TYPE_STRUCT`, `DUCKDB_TYPE_MAP`, `DUCKDB_TYPE_ARRAY`, or `DUCKDB_TYPE_UNION`.
  ///
  /// @param type The primitive type to create.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_logical_type(
    DUCKDB_TYPE type,
  ) {
    return _duckdb_create_logical_type(
      type.value,
    );
  }

  late final _duckdb_create_logical_typePtr = _lookup<
          ffi.NativeFunction<duckdb_logical_type Function(ffi.UnsignedInt)>>(
      'duckdb_create_logical_type');
  late final _duckdb_create_logical_type = _duckdb_create_logical_typePtr
      .asFunction<duckdb_logical_type Function(int)>();

  /// !
  /// Returns the alias of a duckdb_logical_type, if set, else `nullptr`.
  /// The result must be destroyed with `duckdb_free`.
  ///
  /// @param type The logical type
  /// @return The alias or `nullptr`
  ffi.Pointer<ffi.Char> duckdb_logical_type_get_alias(
    duckdb_logical_type type,
  ) {
    return _duckdb_logical_type_get_alias(
      type,
    );
  }

  late final _duckdb_logical_type_get_aliasPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type)>>(
      'duckdb_logical_type_get_alias');
  late final _duckdb_logical_type_get_alias = _duckdb_logical_type_get_aliasPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type)>();

  /// !
  /// Sets the alias of a duckdb_logical_type.
  ///
  /// @param type The logical type
  /// @param alias The alias to set
  void duckdb_logical_type_set_alias(
    duckdb_logical_type type,
    ffi.Pointer<ffi.Char> alias,
  ) {
    return _duckdb_logical_type_set_alias(
      type,
      alias,
    );
  }

  late final _duckdb_logical_type_set_aliasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_logical_type,
              ffi.Pointer<ffi.Char>)>>('duckdb_logical_type_set_alias');
  late final _duckdb_logical_type_set_alias = _duckdb_logical_type_set_aliasPtr
      .asFunction<void Function(duckdb_logical_type, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates a LIST type from its child type.
  /// The return type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The child type of the list
  /// @return The logical type.
  duckdb_logical_type duckdb_create_list_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_create_list_type(
      type,
    );
  }

  late final _duckdb_create_list_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(duckdb_logical_type)>>(
      'duckdb_create_list_type');
  late final _duckdb_create_list_type = _duckdb_create_list_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Creates an ARRAY type from its child type.
  /// The return type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The child type of the array.
  /// @param array_size The number of elements in the array.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_array_type(
    duckdb_logical_type type,
    int array_size,
  ) {
    return _duckdb_create_array_type(
      type,
      array_size,
    );
  }

  late final _duckdb_create_array_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, idx_t)>>('duckdb_create_array_type');
  late final _duckdb_create_array_type = _duckdb_create_array_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type, int)>();

  /// !
  /// Creates a MAP type from its key type and value type.
  /// The return type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param key_type The map's key type.
  /// @param value_type The map's value type.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_map_type(
    duckdb_logical_type key_type,
    duckdb_logical_type value_type,
  ) {
    return _duckdb_create_map_type(
      key_type,
      value_type,
    );
  }

  late final _duckdb_create_map_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(duckdb_logical_type,
              duckdb_logical_type)>>('duckdb_create_map_type');
  late final _duckdb_create_map_type = _duckdb_create_map_typePtr.asFunction<
      duckdb_logical_type Function(duckdb_logical_type, duckdb_logical_type)>();

  /// !
  /// Creates a UNION type from the passed arrays.
  /// The return type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param member_types The array of union member types.
  /// @param member_names The union member names.
  /// @param member_count The number of union members.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_union_type(
    ffi.Pointer<duckdb_logical_type> member_types,
    ffi.Pointer<ffi.Pointer<ffi.Char>> member_names,
    int member_count,
  ) {
    return _duckdb_create_union_type(
      member_types,
      member_names,
      member_count,
    );
  }

  late final _duckdb_create_union_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              idx_t)>>('duckdb_create_union_type');
  late final _duckdb_create_union_type =
      _duckdb_create_union_typePtr.asFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// !
  /// Creates a STRUCT type based on the member types and names.
  /// The resulting type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param member_types The array of types of the struct members.
  /// @param member_names The array of names of the struct members.
  /// @param member_count The number of members of the struct.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_struct_type(
    ffi.Pointer<duckdb_logical_type> member_types,
    ffi.Pointer<ffi.Pointer<ffi.Char>> member_names,
    int member_count,
  ) {
    return _duckdb_create_struct_type(
      member_types,
      member_names,
      member_count,
    );
  }

  late final _duckdb_create_struct_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              idx_t)>>('duckdb_create_struct_type');
  late final _duckdb_create_struct_type =
      _duckdb_create_struct_typePtr.asFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// !
  /// Creates an ENUM type from the passed member name array.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param member_names The array of names that the enum should consist of.
  /// @param member_count The number of elements that were specified in the array.
  /// @return The logical type.
  duckdb_logical_type duckdb_create_enum_type(
    ffi.Pointer<ffi.Pointer<ffi.Char>> member_names,
    int member_count,
  ) {
    return _duckdb_create_enum_type(
      member_names,
      member_count,
    );
  }

  late final _duckdb_create_enum_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              idx_t)>>('duckdb_create_enum_type');
  late final _duckdb_create_enum_type = _duckdb_create_enum_typePtr.asFunction<
      duckdb_logical_type Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// !
  /// Creates a DECIMAL type with the specified width and scale.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param width The width of the decimal type
  /// @param scale The scale of the decimal type
  /// @return The logical type.
  duckdb_logical_type duckdb_create_decimal_type(
    int width,
    int scale,
  ) {
    return _duckdb_create_decimal_type(
      width,
      scale,
    );
  }

  late final _duckdb_create_decimal_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(ffi.Uint8, ffi.Uint8)>>(
      'duckdb_create_decimal_type');
  late final _duckdb_create_decimal_type = _duckdb_create_decimal_typePtr
      .asFunction<duckdb_logical_type Function(int, int)>();

  /// !
  /// Retrieves the enum `duckdb_type` of a `duckdb_logical_type`.
  ///
  /// @param type The logical type.
  /// @return The `duckdb_type` id.
  DUCKDB_TYPE duckdb_get_type_id(
    duckdb_logical_type type,
  ) {
    return DUCKDB_TYPE.fromValue(_duckdb_get_type_id(
      type,
    ));
  }

  late final _duckdb_get_type_idPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_logical_type)>>(
      'duckdb_get_type_id');
  late final _duckdb_get_type_id =
      _duckdb_get_type_idPtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the width of a decimal type.
  ///
  /// @param type The logical type object
  /// @return The width of the decimal type
  int duckdb_decimal_width(
    duckdb_logical_type type,
  ) {
    return _duckdb_decimal_width(
      type,
    );
  }

  late final _duckdb_decimal_widthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(duckdb_logical_type)>>(
          'duckdb_decimal_width');
  late final _duckdb_decimal_width =
      _duckdb_decimal_widthPtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the scale of a decimal type.
  ///
  /// @param type The logical type object
  /// @return The scale of the decimal type
  int duckdb_decimal_scale(
    duckdb_logical_type type,
  ) {
    return _duckdb_decimal_scale(
      type,
    );
  }

  late final _duckdb_decimal_scalePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(duckdb_logical_type)>>(
          'duckdb_decimal_scale');
  late final _duckdb_decimal_scale =
      _duckdb_decimal_scalePtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the internal storage type of a decimal type.
  ///
  /// @param type The logical type object
  /// @return The internal type of the decimal type
  DUCKDB_TYPE duckdb_decimal_internal_type(
    duckdb_logical_type type,
  ) {
    return DUCKDB_TYPE.fromValue(_duckdb_decimal_internal_type(
      type,
    ));
  }

  late final _duckdb_decimal_internal_typePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_logical_type)>>(
      'duckdb_decimal_internal_type');
  late final _duckdb_decimal_internal_type = _duckdb_decimal_internal_typePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the internal storage type of an enum type.
  ///
  /// @param type The logical type object
  /// @return The internal type of the enum type
  DUCKDB_TYPE duckdb_enum_internal_type(
    duckdb_logical_type type,
  ) {
    return DUCKDB_TYPE.fromValue(_duckdb_enum_internal_type(
      type,
    ));
  }

  late final _duckdb_enum_internal_typePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_logical_type)>>(
      'duckdb_enum_internal_type');
  late final _duckdb_enum_internal_type = _duckdb_enum_internal_typePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the dictionary size of the enum type.
  ///
  /// @param type The logical type object
  /// @return The dictionary size of the enum type
  int duckdb_enum_dictionary_size(
    duckdb_logical_type type,
  ) {
    return _duckdb_enum_dictionary_size(
      type,
    );
  }

  late final _duckdb_enum_dictionary_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(duckdb_logical_type)>>(
          'duckdb_enum_dictionary_size');
  late final _duckdb_enum_dictionary_size = _duckdb_enum_dictionary_sizePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the dictionary value at the specified position from the enum.
  ///
  /// The result must be freed with `duckdb_free`.
  ///
  /// @param type The logical type object
  /// @param index The index in the dictionary
  /// @return The string value of the enum type. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_enum_dictionary_value(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_enum_dictionary_value(
      type,
      index,
    );
  }

  late final _duckdb_enum_dictionary_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_enum_dictionary_value');
  late final _duckdb_enum_dictionary_value = _duckdb_enum_dictionary_valuePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given LIST type. Also accepts MAP types.
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type, either LIST or MAP.
  /// @return The child type of the LIST or MAP type.
  duckdb_logical_type duckdb_list_type_child_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_list_type_child_type(
      type,
    );
  }

  late final _duckdb_list_type_child_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(duckdb_logical_type)>>(
      'duckdb_list_type_child_type');
  late final _duckdb_list_type_child_type = _duckdb_list_type_child_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the child type of the given ARRAY type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type. Must be ARRAY.
  /// @return The child type of the ARRAY type.
  duckdb_logical_type duckdb_array_type_child_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_array_type_child_type(
      type,
    );
  }

  late final _duckdb_array_type_child_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(duckdb_logical_type)>>(
      'duckdb_array_type_child_type');
  late final _duckdb_array_type_child_type = _duckdb_array_type_child_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the array size of the given array type.
  ///
  /// @param type The logical type object
  /// @return The fixed number of elements the values of this array type can store.
  int duckdb_array_type_array_size(
    duckdb_logical_type type,
  ) {
    return _duckdb_array_type_array_size(
      type,
    );
  }

  late final _duckdb_array_type_array_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_logical_type)>>(
          'duckdb_array_type_array_size');
  late final _duckdb_array_type_array_size = _duckdb_array_type_array_sizePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the key type of the given map type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type object
  /// @return The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_map_type_key_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_map_type_key_type(
      type,
    );
  }

  late final _duckdb_map_type_key_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(duckdb_logical_type)>>(
      'duckdb_map_type_key_type');
  late final _duckdb_map_type_key_type = _duckdb_map_type_key_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the value type of the given map type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type object
  /// @return The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_map_type_value_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_map_type_value_type(
      type,
    );
  }

  late final _duckdb_map_type_value_typePtr = _lookup<
          ffi
          .NativeFunction<duckdb_logical_type Function(duckdb_logical_type)>>(
      'duckdb_map_type_value_type');
  late final _duckdb_map_type_value_type = _duckdb_map_type_value_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Returns the number of children of a struct type.
  ///
  /// @param type The logical type object
  /// @return The number of children of a struct type.
  int duckdb_struct_type_child_count(
    duckdb_logical_type type,
  ) {
    return _duckdb_struct_type_child_count(
      type,
    );
  }

  late final _duckdb_struct_type_child_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_logical_type)>>(
          'duckdb_struct_type_child_count');
  late final _duckdb_struct_type_child_count =
      _duckdb_struct_type_child_countPtr
          .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the name of the struct child.
  ///
  /// The result must be freed with `duckdb_free`.
  ///
  /// @param type The logical type object
  /// @param index The child index
  /// @return The name of the struct type. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_struct_type_child_name(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_struct_type_child_name(
      type,
      index,
    );
  }

  late final _duckdb_struct_type_child_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_struct_type_child_name');
  late final _duckdb_struct_type_child_name = _duckdb_struct_type_child_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given struct type at the specified index.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type object
  /// @param index The child index
  /// @return The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_struct_type_child_type(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_struct_type_child_type(
      type,
      index,
    );
  }

  late final _duckdb_struct_type_child_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, idx_t)>>('duckdb_struct_type_child_type');
  late final _duckdb_struct_type_child_type = _duckdb_struct_type_child_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type, int)>();

  /// !
  /// Returns the number of members that the union type has.
  ///
  /// @param type The logical type (union) object
  /// @return The number of members of a union type.
  int duckdb_union_type_member_count(
    duckdb_logical_type type,
  ) {
    return _duckdb_union_type_member_count(
      type,
    );
  }

  late final _duckdb_union_type_member_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_logical_type)>>(
          'duckdb_union_type_member_count');
  late final _duckdb_union_type_member_count =
      _duckdb_union_type_member_countPtr
          .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the name of the union member.
  ///
  /// The result must be freed with `duckdb_free`.
  ///
  /// @param type The logical type object
  /// @param index The child index
  /// @return The name of the union member. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_union_type_member_name(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_union_type_member_name(
      type,
      index,
    );
  }

  late final _duckdb_union_type_member_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_union_type_member_name');
  late final _duckdb_union_type_member_name = _duckdb_union_type_member_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given union member at the specified index.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`.
  ///
  /// @param type The logical type object
  /// @param index The child index
  /// @return The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_union_type_member_type(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_union_type_member_type(
      type,
      index,
    );
  }

  late final _duckdb_union_type_member_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, idx_t)>>('duckdb_union_type_member_type');
  late final _duckdb_union_type_member_type = _duckdb_union_type_member_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type, int)>();

  /// !
  /// Destroys the logical type and de-allocates all memory allocated for that type.
  ///
  /// @param type The logical type to destroy.
  void duckdb_destroy_logical_type(
    ffi.Pointer<duckdb_logical_type> type,
  ) {
    return _duckdb_destroy_logical_type(
      type,
    );
  }

  late final _duckdb_destroy_logical_typePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_logical_type>)>>(
      'duckdb_destroy_logical_type');
  late final _duckdb_destroy_logical_type = _duckdb_destroy_logical_typePtr
      .asFunction<void Function(ffi.Pointer<duckdb_logical_type>)>();

  /// !
  /// Registers a custom type within the given connection.
  /// The type must have an alias
  ///
  /// @param con The connection to use
  /// @param type The custom type to register
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_logical_type(
    duckdb_connection con,
    duckdb_logical_type type,
    duckdb_create_type_info info,
  ) {
    return duckdb_state.fromValue(_duckdb_register_logical_type(
      con,
      type,
      info,
    ));
  }

  late final _duckdb_register_logical_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection, duckdb_logical_type,
              duckdb_create_type_info)>>('duckdb_register_logical_type');
  late final _duckdb_register_logical_type =
      _duckdb_register_logical_typePtr.asFunction<
          int Function(duckdb_connection, duckdb_logical_type,
              duckdb_create_type_info)>();

  /// !
  /// Creates an empty data chunk with the specified column types.
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// @param types An array of column types. Column types can not contain ANY and INVALID types.
  /// @param column_count The number of columns.
  /// @return The data chunk.
  duckdb_data_chunk duckdb_create_data_chunk(
    ffi.Pointer<duckdb_logical_type> types,
    int column_count,
  ) {
    return _duckdb_create_data_chunk(
      types,
      column_count,
    );
  }

  late final _duckdb_create_data_chunkPtr = _lookup<
      ffi.NativeFunction<
          duckdb_data_chunk Function(ffi.Pointer<duckdb_logical_type>,
              idx_t)>>('duckdb_create_data_chunk');
  late final _duckdb_create_data_chunk =
      _duckdb_create_data_chunkPtr.asFunction<
          duckdb_data_chunk Function(ffi.Pointer<duckdb_logical_type>, int)>();

  /// !
  /// Destroys the data chunk and de-allocates all memory allocated for that chunk.
  ///
  /// @param chunk The data chunk to destroy.
  void duckdb_destroy_data_chunk(
    ffi.Pointer<duckdb_data_chunk> chunk,
  ) {
    return _duckdb_destroy_data_chunk(
      chunk,
    );
  }

  late final _duckdb_destroy_data_chunkPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_data_chunk>)>>(
      'duckdb_destroy_data_chunk');
  late final _duckdb_destroy_data_chunk = _duckdb_destroy_data_chunkPtr
      .asFunction<void Function(ffi.Pointer<duckdb_data_chunk>)>();

  /// !
  /// Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
  /// After calling this method, you must call `duckdb_vector_get_validity` and `duckdb_vector_get_data` to obtain current
  /// data and validity pointers
  ///
  /// @param chunk The data chunk to reset.
  void duckdb_data_chunk_reset(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_reset(
      chunk,
    );
  }

  late final _duckdb_data_chunk_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_reset');
  late final _duckdb_data_chunk_reset = _duckdb_data_chunk_resetPtr
      .asFunction<void Function(duckdb_data_chunk)>();

  /// !
  /// Retrieves the number of columns in a data chunk.
  ///
  /// @param chunk The data chunk to get the data from
  /// @return The number of columns in the data chunk
  int duckdb_data_chunk_get_column_count(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_get_column_count(
      chunk,
    );
  }

  late final _duckdb_data_chunk_get_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_get_column_count');
  late final _duckdb_data_chunk_get_column_count =
      _duckdb_data_chunk_get_column_countPtr
          .asFunction<int Function(duckdb_data_chunk)>();

  /// !
  /// Retrieves the vector at the specified column index in the data chunk.
  ///
  /// The pointer to the vector is valid for as long as the chunk is alive.
  /// It does NOT need to be destroyed.
  ///
  /// @param chunk The data chunk to get the data from
  /// @return The vector
  duckdb_vector duckdb_data_chunk_get_vector(
    duckdb_data_chunk chunk,
    int col_idx,
  ) {
    return _duckdb_data_chunk_get_vector(
      chunk,
      col_idx,
    );
  }

  late final _duckdb_data_chunk_get_vectorPtr = _lookup<
          ffi.NativeFunction<duckdb_vector Function(duckdb_data_chunk, idx_t)>>(
      'duckdb_data_chunk_get_vector');
  late final _duckdb_data_chunk_get_vector = _duckdb_data_chunk_get_vectorPtr
      .asFunction<duckdb_vector Function(duckdb_data_chunk, int)>();

  /// !
  /// Retrieves the current number of tuples in a data chunk.
  ///
  /// @param chunk The data chunk to get the data from
  /// @return The number of tuples in the data chunk
  int duckdb_data_chunk_get_size(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_get_size(
      chunk,
    );
  }

  late final _duckdb_data_chunk_get_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_get_size');
  late final _duckdb_data_chunk_get_size = _duckdb_data_chunk_get_sizePtr
      .asFunction<int Function(duckdb_data_chunk)>();

  /// !
  /// Sets the current number of tuples in a data chunk.
  ///
  /// @param chunk The data chunk to set the size in
  /// @param size The number of tuples in the data chunk
  void duckdb_data_chunk_set_size(
    duckdb_data_chunk chunk,
    int size,
  ) {
    return _duckdb_data_chunk_set_size(
      chunk,
      size,
    );
  }

  late final _duckdb_data_chunk_set_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_data_chunk, idx_t)>>(
          'duckdb_data_chunk_set_size');
  late final _duckdb_data_chunk_set_size = _duckdb_data_chunk_set_sizePtr
      .asFunction<void Function(duckdb_data_chunk, int)>();

  /// !
  /// Retrieves the column type of the specified vector.
  ///
  /// The result must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param vector The vector get the data from
  /// @return The type of the vector
  duckdb_logical_type duckdb_vector_get_column_type(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_column_type(
      vector,
    );
  }

  late final _duckdb_vector_get_column_typePtr =
      _lookup<ffi.NativeFunction<duckdb_logical_type Function(duckdb_vector)>>(
          'duckdb_vector_get_column_type');
  late final _duckdb_vector_get_column_type = _duckdb_vector_get_column_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_vector)>();

  /// !
  /// Retrieves the data pointer of the vector.
  ///
  /// The data pointer can be used to read or write values from the vector.
  /// How to read or write values depends on the type of the vector.
  ///
  /// @param vector The vector to get the data from
  /// @return The data pointer
  ffi.Pointer<ffi.Void> duckdb_vector_get_data(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_data(
      vector,
    );
  }

  late final _duckdb_vector_get_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_vector)>>(
      'duckdb_vector_get_data');
  late final _duckdb_vector_get_data = _duckdb_vector_get_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_vector)>();

  /// !
  /// Retrieves the validity mask pointer of the specified vector.
  ///
  /// If all values are valid, this function MIGHT return NULL!
  ///
  /// The validity mask is a bitset that signifies null-ness within the data chunk.
  /// It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
  /// The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
  ///
  /// Validity of a specific value can be obtained like this:
  ///
  /// idx_t entry_idx = row_idx / 64;
  /// idx_t idx_in_entry = row_idx % 64;
  /// bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
  ///
  /// Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
  ///
  /// @param vector The vector to get the data from
  /// @return The pointer to the validity mask, or NULL if no validity mask is present
  ffi.Pointer<ffi.Uint64> duckdb_vector_get_validity(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_validity(
      vector,
    );
  }

  late final _duckdb_vector_get_validityPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Uint64> Function(duckdb_vector)>>(
      'duckdb_vector_get_validity');
  late final _duckdb_vector_get_validity = _duckdb_vector_get_validityPtr
      .asFunction<ffi.Pointer<ffi.Uint64> Function(duckdb_vector)>();

  /// !
  /// Ensures the validity mask is writable by allocating it.
  ///
  /// After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
  /// This allows NULL values to be written to the vector, regardless of whether a validity mask was present before.
  ///
  /// @param vector The vector to alter
  void duckdb_vector_ensure_validity_writable(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_ensure_validity_writable(
      vector,
    );
  }

  late final _duckdb_vector_ensure_validity_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_vector)>>(
          'duckdb_vector_ensure_validity_writable');
  late final _duckdb_vector_ensure_validity_writable =
      _duckdb_vector_ensure_validity_writablePtr
          .asFunction<void Function(duckdb_vector)>();

  /// !
  /// Assigns a string element in the vector at the specified location.
  ///
  /// @param vector The vector to alter
  /// @param index The row position in the vector to assign the string to
  /// @param str The null-terminated string
  void duckdb_vector_assign_string_element(
    duckdb_vector vector,
    int index,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _duckdb_vector_assign_string_element(
      vector,
      index,
      str,
    );
  }

  late final _duckdb_vector_assign_string_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_vector, idx_t,
              ffi.Pointer<ffi.Char>)>>('duckdb_vector_assign_string_element');
  late final _duckdb_vector_assign_string_element =
      _duckdb_vector_assign_string_elementPtr.asFunction<
          void Function(duckdb_vector, int, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Assigns a string element in the vector at the specified location. You may also use this function to assign BLOBs.
  ///
  /// @param vector The vector to alter
  /// @param index The row position in the vector to assign the string to
  /// @param str The string
  /// @param str_len The length of the string (in bytes)
  void duckdb_vector_assign_string_element_len(
    duckdb_vector vector,
    int index,
    ffi.Pointer<ffi.Char> str,
    int str_len,
  ) {
    return _duckdb_vector_assign_string_element_len(
      vector,
      index,
      str,
      str_len,
    );
  }

  late final _duckdb_vector_assign_string_element_lenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_vector, idx_t, ffi.Pointer<ffi.Char>,
              idx_t)>>('duckdb_vector_assign_string_element_len');
  late final _duckdb_vector_assign_string_element_len =
      _duckdb_vector_assign_string_element_lenPtr.asFunction<
          void Function(duckdb_vector, int, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Retrieves the child vector of a list vector.
  ///
  /// The resulting vector is valid as long as the parent vector is valid.
  ///
  /// @param vector The vector
  /// @return The child vector
  duckdb_vector duckdb_list_vector_get_child(
    duckdb_vector vector,
  ) {
    return _duckdb_list_vector_get_child(
      vector,
    );
  }

  late final _duckdb_list_vector_get_childPtr =
      _lookup<ffi.NativeFunction<duckdb_vector Function(duckdb_vector)>>(
          'duckdb_list_vector_get_child');
  late final _duckdb_list_vector_get_child = _duckdb_list_vector_get_childPtr
      .asFunction<duckdb_vector Function(duckdb_vector)>();

  /// !
  /// Returns the size of the child vector of the list.
  ///
  /// @param vector The vector
  /// @return The size of the child list
  int duckdb_list_vector_get_size(
    duckdb_vector vector,
  ) {
    return _duckdb_list_vector_get_size(
      vector,
    );
  }

  late final _duckdb_list_vector_get_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_vector)>>(
          'duckdb_list_vector_get_size');
  late final _duckdb_list_vector_get_size =
      _duckdb_list_vector_get_sizePtr.asFunction<int Function(duckdb_vector)>();

  /// !
  /// Sets the total size of the underlying child-vector of a list vector.
  ///
  /// @param vector The list vector.
  /// @param size The size of the child list.
  /// @return The duckdb state. Returns DuckDBError if the vector is nullptr.
  duckdb_state duckdb_list_vector_set_size(
    duckdb_vector vector,
    Dartidx_t size,
  ) {
    return duckdb_state.fromValue(_duckdb_list_vector_set_size(
      vector,
      size,
    ));
  }

  late final _duckdb_list_vector_set_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_vector, idx_t)>>(
      'duckdb_list_vector_set_size');
  late final _duckdb_list_vector_set_size = _duckdb_list_vector_set_sizePtr
      .asFunction<int Function(duckdb_vector, int)>();

  /// !
  /// Sets the total capacity of the underlying child-vector of a list.
  ///
  /// After calling this method, you must call `duckdb_vector_get_validity` and `duckdb_vector_get_data` to obtain current
  /// data and validity pointers
  ///
  /// @param vector The list vector.
  /// @param required_capacity the total capacity to reserve.
  /// @return The duckdb state. Returns DuckDBError if the vector is nullptr.
  duckdb_state duckdb_list_vector_reserve(
    duckdb_vector vector,
    Dartidx_t required_capacity,
  ) {
    return duckdb_state.fromValue(_duckdb_list_vector_reserve(
      vector,
      required_capacity,
    ));
  }

  late final _duckdb_list_vector_reservePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_vector, idx_t)>>(
      'duckdb_list_vector_reserve');
  late final _duckdb_list_vector_reserve = _duckdb_list_vector_reservePtr
      .asFunction<int Function(duckdb_vector, int)>();

  /// !
  /// Retrieves the child vector of a struct vector.
  ///
  /// The resulting vector is valid as long as the parent vector is valid.
  ///
  /// @param vector The vector
  /// @param index The child index
  /// @return The child vector
  duckdb_vector duckdb_struct_vector_get_child(
    duckdb_vector vector,
    int index,
  ) {
    return _duckdb_struct_vector_get_child(
      vector,
      index,
    );
  }

  late final _duckdb_struct_vector_get_childPtr =
      _lookup<ffi.NativeFunction<duckdb_vector Function(duckdb_vector, idx_t)>>(
          'duckdb_struct_vector_get_child');
  late final _duckdb_struct_vector_get_child =
      _duckdb_struct_vector_get_childPtr
          .asFunction<duckdb_vector Function(duckdb_vector, int)>();

  /// !
  /// Retrieves the child vector of a array vector.
  ///
  /// The resulting vector is valid as long as the parent vector is valid.
  /// The resulting vector has the size of the parent vector multiplied by the array size.
  ///
  /// @param vector The vector
  /// @return The child vector
  duckdb_vector duckdb_array_vector_get_child(
    duckdb_vector vector,
  ) {
    return _duckdb_array_vector_get_child(
      vector,
    );
  }

  late final _duckdb_array_vector_get_childPtr =
      _lookup<ffi.NativeFunction<duckdb_vector Function(duckdb_vector)>>(
          'duckdb_array_vector_get_child');
  late final _duckdb_array_vector_get_child = _duckdb_array_vector_get_childPtr
      .asFunction<duckdb_vector Function(duckdb_vector)>();

  /// !
  /// Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.
  ///
  /// @param validity The validity mask, as obtained through `duckdb_vector_get_validity`
  /// @param row The row index
  /// @return true if the row is valid, false otherwise
  bool duckdb_validity_row_is_valid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_row_is_valid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_row_is_validPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Uint64>, idx_t)>>(
      'duckdb_validity_row_is_valid');
  late final _duckdb_validity_row_is_valid = _duckdb_validity_row_is_validPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// In a validity mask, sets a specific row to either valid or invalid.
  ///
  /// Note that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,
  /// to ensure that there is a validity mask to write to.
  ///
  /// @param validity The validity mask, as obtained through `duckdb_vector_get_validity`.
  /// @param row The row index
  /// @param valid Whether or not to set the row to valid, or invalid
  void duckdb_validity_set_row_validity(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
    bool valid,
  ) {
    return _duckdb_validity_set_row_validity(
      validity,
      row,
      valid,
    );
  }

  late final _duckdb_validity_set_row_validityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint64>, idx_t,
              ffi.Bool)>>('duckdb_validity_set_row_validity');
  late final _duckdb_validity_set_row_validity =
      _duckdb_validity_set_row_validityPtr
          .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int, bool)>();

  /// !
  /// In a validity mask, sets a specific row to invalid.
  ///
  /// Equivalent to `duckdb_validity_set_row_validity` with valid set to false.
  ///
  /// @param validity The validity mask
  /// @param row The row index
  void duckdb_validity_set_row_invalid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_set_row_invalid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_set_row_invalidPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint64>, idx_t)>>(
      'duckdb_validity_set_row_invalid');
  late final _duckdb_validity_set_row_invalid =
      _duckdb_validity_set_row_invalidPtr
          .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// In a validity mask, sets a specific row to valid.
  ///
  /// Equivalent to `duckdb_validity_set_row_validity` with valid set to true.
  ///
  /// @param validity The validity mask
  /// @param row The row index
  void duckdb_validity_set_row_valid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_set_row_valid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_set_row_validPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint64>, idx_t)>>(
      'duckdb_validity_set_row_valid');
  late final _duckdb_validity_set_row_valid = _duckdb_validity_set_row_validPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// Creates a new empty scalar function.
  ///
  /// The return value should be destroyed with `duckdb_destroy_scalar_function`.
  ///
  /// @return The scalar function object.
  duckdb_scalar_function duckdb_create_scalar_function() {
    return _duckdb_create_scalar_function();
  }

  late final _duckdb_create_scalar_functionPtr =
      _lookup<ffi.NativeFunction<duckdb_scalar_function Function()>>(
          'duckdb_create_scalar_function');
  late final _duckdb_create_scalar_function = _duckdb_create_scalar_functionPtr
      .asFunction<duckdb_scalar_function Function()>();

  /// !
  /// Destroys the given scalar function object.
  ///
  /// @param scalar_function The scalar function to destroy
  void duckdb_destroy_scalar_function(
    ffi.Pointer<duckdb_scalar_function> scalar_function,
  ) {
    return _duckdb_destroy_scalar_function(
      scalar_function,
    );
  }

  late final _duckdb_destroy_scalar_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_scalar_function>)>>(
      'duckdb_destroy_scalar_function');
  late final _duckdb_destroy_scalar_function =
      _duckdb_destroy_scalar_functionPtr
          .asFunction<void Function(ffi.Pointer<duckdb_scalar_function>)>();

  /// !
  /// Sets the name of the given scalar function.
  ///
  /// @param scalar_function The scalar function
  /// @param name The name of the scalar function
  void duckdb_scalar_function_set_name(
    duckdb_scalar_function scalar_function,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_scalar_function_set_name(
      scalar_function,
      name,
    );
  }

  late final _duckdb_scalar_function_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_scalar_function,
              ffi.Pointer<ffi.Char>)>>('duckdb_scalar_function_set_name');
  late final _duckdb_scalar_function_set_name =
      _duckdb_scalar_function_set_namePtr.asFunction<
          void Function(duckdb_scalar_function, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Sets the parameters of the given scalar function to varargs. Does not require adding parameters with
  /// duckdb_scalar_function_add_parameter.
  ///
  /// @param scalar_function The scalar function.
  /// @param type The type of the arguments.
  /// @return The parameter type. Cannot contain INVALID.
  void duckdb_scalar_function_set_varargs(
    duckdb_scalar_function scalar_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_scalar_function_set_varargs(
      scalar_function,
      type,
    );
  }

  late final _duckdb_scalar_function_set_varargsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_scalar_function,
              duckdb_logical_type)>>('duckdb_scalar_function_set_varargs');
  late final _duckdb_scalar_function_set_varargs =
      _duckdb_scalar_function_set_varargsPtr.asFunction<
          void Function(duckdb_scalar_function, duckdb_logical_type)>();

  /// !
  /// Sets the parameters of the given scalar function to varargs. Does not require adding parameters with
  /// duckdb_scalar_function_add_parameter.
  ///
  /// @param scalar_function The scalar function.
  void duckdb_scalar_function_set_special_handling(
    duckdb_scalar_function scalar_function,
  ) {
    return _duckdb_scalar_function_set_special_handling(
      scalar_function,
    );
  }

  late final _duckdb_scalar_function_set_special_handlingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_scalar_function)>>(
          'duckdb_scalar_function_set_special_handling');
  late final _duckdb_scalar_function_set_special_handling =
      _duckdb_scalar_function_set_special_handlingPtr
          .asFunction<void Function(duckdb_scalar_function)>();

  /// !
  /// Sets the Function Stability of the scalar function to VOLATILE, indicating the function should be re-run for every row.
  /// This limits optimization that can be performed for the function.
  ///
  /// @param scalar_function The scalar function.
  void duckdb_scalar_function_set_volatile(
    duckdb_scalar_function scalar_function,
  ) {
    return _duckdb_scalar_function_set_volatile(
      scalar_function,
    );
  }

  late final _duckdb_scalar_function_set_volatilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_scalar_function)>>(
          'duckdb_scalar_function_set_volatile');
  late final _duckdb_scalar_function_set_volatile =
      _duckdb_scalar_function_set_volatilePtr
          .asFunction<void Function(duckdb_scalar_function)>();

  /// !
  /// Adds a parameter to the scalar function.
  ///
  /// @param scalar_function The scalar function.
  /// @param type The parameter type. Cannot contain INVALID.
  void duckdb_scalar_function_add_parameter(
    duckdb_scalar_function scalar_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_scalar_function_add_parameter(
      scalar_function,
      type,
    );
  }

  late final _duckdb_scalar_function_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_scalar_function,
              duckdb_logical_type)>>('duckdb_scalar_function_add_parameter');
  late final _duckdb_scalar_function_add_parameter =
      _duckdb_scalar_function_add_parameterPtr.asFunction<
          void Function(duckdb_scalar_function, duckdb_logical_type)>();

  /// !
  /// Sets the return type of the scalar function.
  ///
  /// @param scalar_function The scalar function
  /// @param type Cannot contain INVALID or ANY.
  void duckdb_scalar_function_set_return_type(
    duckdb_scalar_function scalar_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_scalar_function_set_return_type(
      scalar_function,
      type,
    );
  }

  late final _duckdb_scalar_function_set_return_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_scalar_function,
              duckdb_logical_type)>>('duckdb_scalar_function_set_return_type');
  late final _duckdb_scalar_function_set_return_type =
      _duckdb_scalar_function_set_return_typePtr.asFunction<
          void Function(duckdb_scalar_function, duckdb_logical_type)>();

  /// !
  /// Assigns extra information to the scalar function that can be fetched during binding, etc.
  ///
  /// @param scalar_function The scalar function
  /// @param extra_info The extra information
  /// @param destroy The callback that will be called to destroy the bind data (if any)
  void duckdb_scalar_function_set_extra_info(
    duckdb_scalar_function scalar_function,
    ffi.Pointer<ffi.Void> extra_info,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_scalar_function_set_extra_info(
      scalar_function,
      extra_info,
      destroy,
    );
  }

  late final _duckdb_scalar_function_set_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_scalar_function, ffi.Pointer<ffi.Void>,
                  duckdb_delete_callback_t)>>(
      'duckdb_scalar_function_set_extra_info');
  late final _duckdb_scalar_function_set_extra_info =
      _duckdb_scalar_function_set_extra_infoPtr.asFunction<
          void Function(duckdb_scalar_function, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Sets the main function of the scalar function.
  ///
  /// @param scalar_function The scalar function
  /// @param function The function
  void duckdb_scalar_function_set_function(
    duckdb_scalar_function scalar_function,
    duckdb_scalar_function_t function,
  ) {
    return _duckdb_scalar_function_set_function(
      scalar_function,
      function,
    );
  }

  late final _duckdb_scalar_function_set_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_scalar_function, duckdb_scalar_function_t)>>(
      'duckdb_scalar_function_set_function');
  late final _duckdb_scalar_function_set_function =
      _duckdb_scalar_function_set_functionPtr.asFunction<
          void Function(duckdb_scalar_function, duckdb_scalar_function_t)>();

  /// !
  /// Register the scalar function object within the given connection.
  ///
  /// The function requires at least a name, a function and a return type.
  ///
  /// If the function is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// @param con The connection to register it in.
  /// @param scalar_function The function pointer
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_scalar_function(
    duckdb_connection con,
    duckdb_scalar_function scalar_function,
  ) {
    return duckdb_state.fromValue(_duckdb_register_scalar_function(
      con,
      scalar_function,
    ));
  }

  late final _duckdb_register_scalar_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection,
              duckdb_scalar_function)>>('duckdb_register_scalar_function');
  late final _duckdb_register_scalar_function =
      _duckdb_register_scalar_functionPtr.asFunction<
          int Function(duckdb_connection, duckdb_scalar_function)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_scalar_function_set_extra_info`.
  ///
  /// @param info The info object.
  /// @return The extra info.
  ffi.Pointer<ffi.Void> duckdb_scalar_function_get_extra_info(
    duckdb_function_info info,
  ) {
    return _duckdb_scalar_function_get_extra_info(
      info,
    );
  }

  late final _duckdb_scalar_function_get_extra_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_scalar_function_get_extra_info');
  late final _duckdb_scalar_function_get_extra_info =
      _duckdb_scalar_function_get_extra_infoPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Report that an error has occurred while executing the scalar function.
  ///
  /// @param info The info object.
  /// @param error The error message
  void duckdb_scalar_function_set_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_scalar_function_set_error(
      info,
      error,
    );
  }

  late final _duckdb_scalar_function_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_scalar_function_set_error');
  late final _duckdb_scalar_function_set_error =
      _duckdb_scalar_function_set_errorPtr.asFunction<
          void Function(duckdb_function_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates a new empty scalar function set.
  ///
  /// The return value should be destroyed with `duckdb_destroy_scalar_function_set`.
  ///
  /// @return The scalar function set object.
  duckdb_scalar_function_set duckdb_create_scalar_function_set(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_create_scalar_function_set(
      name,
    );
  }

  late final _duckdb_create_scalar_function_setPtr = _lookup<
      ffi.NativeFunction<
          duckdb_scalar_function_set Function(
              ffi.Pointer<ffi.Char>)>>('duckdb_create_scalar_function_set');
  late final _duckdb_create_scalar_function_set =
      _duckdb_create_scalar_function_setPtr.asFunction<
          duckdb_scalar_function_set Function(ffi.Pointer<ffi.Char>)>();

  /// !
  /// Destroys the given scalar function set object.
  void duckdb_destroy_scalar_function_set(
    ffi.Pointer<duckdb_scalar_function_set> scalar_function_set,
  ) {
    return _duckdb_destroy_scalar_function_set(
      scalar_function_set,
    );
  }

  late final _duckdb_destroy_scalar_function_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_scalar_function_set>)>>(
      'duckdb_destroy_scalar_function_set');
  late final _duckdb_destroy_scalar_function_set =
      _duckdb_destroy_scalar_function_setPtr
          .asFunction<void Function(ffi.Pointer<duckdb_scalar_function_set>)>();

  /// !
  /// Adds the scalar function as a new overload to the scalar function set.
  ///
  /// Returns DuckDBError if the function could not be added, for example if the overload already exists.
  ///
  /// @param set The scalar function set
  /// @param function The function to add
  duckdb_state duckdb_add_scalar_function_to_set(
    duckdb_scalar_function_set set1,
    duckdb_scalar_function function,
  ) {
    return duckdb_state.fromValue(_duckdb_add_scalar_function_to_set(
      set1,
      function,
    ));
  }

  late final _duckdb_add_scalar_function_to_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_scalar_function_set,
              duckdb_scalar_function)>>('duckdb_add_scalar_function_to_set');
  late final _duckdb_add_scalar_function_to_set =
      _duckdb_add_scalar_function_to_setPtr.asFunction<
          int Function(duckdb_scalar_function_set, duckdb_scalar_function)>();

  /// !
  /// Register the scalar function set within the given connection.
  ///
  /// The set requires at least a single valid overload.
  ///
  /// If the set is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// @param con The connection to register it in.
  /// @param set The function set to register
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_scalar_function_set(
    duckdb_connection con,
    duckdb_scalar_function_set set1,
  ) {
    return duckdb_state.fromValue(_duckdb_register_scalar_function_set(
      con,
      set1,
    ));
  }

  late final _duckdb_register_scalar_function_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection, duckdb_scalar_function_set)>>(
      'duckdb_register_scalar_function_set');
  late final _duckdb_register_scalar_function_set =
      _duckdb_register_scalar_function_setPtr.asFunction<
          int Function(duckdb_connection, duckdb_scalar_function_set)>();

  /// !
  /// Creates a new empty aggregate function.
  ///
  /// The return value should be destroyed with `duckdb_destroy_aggregate_function`.
  ///
  /// @return The aggregate function object.
  duckdb_aggregate_function duckdb_create_aggregate_function() {
    return _duckdb_create_aggregate_function();
  }

  late final _duckdb_create_aggregate_functionPtr =
      _lookup<ffi.NativeFunction<duckdb_aggregate_function Function()>>(
          'duckdb_create_aggregate_function');
  late final _duckdb_create_aggregate_function =
      _duckdb_create_aggregate_functionPtr
          .asFunction<duckdb_aggregate_function Function()>();

  /// !
  /// Destroys the given aggregate function object.
  void duckdb_destroy_aggregate_function(
    ffi.Pointer<duckdb_aggregate_function> aggregate_function,
  ) {
    return _duckdb_destroy_aggregate_function(
      aggregate_function,
    );
  }

  late final _duckdb_destroy_aggregate_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_aggregate_function>)>>(
      'duckdb_destroy_aggregate_function');
  late final _duckdb_destroy_aggregate_function =
      _duckdb_destroy_aggregate_functionPtr
          .asFunction<void Function(ffi.Pointer<duckdb_aggregate_function>)>();

  /// !
  /// Sets the name of the given aggregate function.
  ///
  /// @param aggregate_function The aggregate function
  /// @param name The name of the aggregate function
  void duckdb_aggregate_function_set_name(
    duckdb_aggregate_function aggregate_function,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_aggregate_function_set_name(
      aggregate_function,
      name,
    );
  }

  late final _duckdb_aggregate_function_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_aggregate_function,
              ffi.Pointer<ffi.Char>)>>('duckdb_aggregate_function_set_name');
  late final _duckdb_aggregate_function_set_name =
      _duckdb_aggregate_function_set_namePtr.asFunction<
          void Function(duckdb_aggregate_function, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Adds a parameter to the aggregate function.
  ///
  /// @param aggregate_function The aggregate function.
  /// @param type The parameter type. Cannot contain INVALID.
  void duckdb_aggregate_function_add_parameter(
    duckdb_aggregate_function aggregate_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_aggregate_function_add_parameter(
      aggregate_function,
      type,
    );
  }

  late final _duckdb_aggregate_function_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_aggregate_function,
              duckdb_logical_type)>>('duckdb_aggregate_function_add_parameter');
  late final _duckdb_aggregate_function_add_parameter =
      _duckdb_aggregate_function_add_parameterPtr.asFunction<
          void Function(duckdb_aggregate_function, duckdb_logical_type)>();

  /// !
  /// Sets the return type of the aggregate function.
  ///
  /// @param aggregate_function The aggregate function.
  /// @param type The return type. Cannot contain INVALID or ANY.
  void duckdb_aggregate_function_set_return_type(
    duckdb_aggregate_function aggregate_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_aggregate_function_set_return_type(
      aggregate_function,
      type,
    );
  }

  late final _duckdb_aggregate_function_set_return_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_aggregate_function, duckdb_logical_type)>>(
      'duckdb_aggregate_function_set_return_type');
  late final _duckdb_aggregate_function_set_return_type =
      _duckdb_aggregate_function_set_return_typePtr.asFunction<
          void Function(duckdb_aggregate_function, duckdb_logical_type)>();

  /// !
  /// Sets the main functions of the aggregate function.
  ///
  /// @param aggregate_function The aggregate function
  /// @param state_size state size
  /// @param state_init state init function
  /// @param update update states
  /// @param combine combine states
  /// @param finalize finalize states
  void duckdb_aggregate_function_set_functions(
    duckdb_aggregate_function aggregate_function,
    duckdb_aggregate_state_size state_size,
    duckdb_aggregate_init_t state_init,
    duckdb_aggregate_update_t update,
    duckdb_aggregate_combine_t combine,
    duckdb_aggregate_finalize_t finalize,
  ) {
    return _duckdb_aggregate_function_set_functions(
      aggregate_function,
      state_size,
      state_init,
      update,
      combine,
      finalize,
    );
  }

  late final _duckdb_aggregate_function_set_functionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_aggregate_function,
                  duckdb_aggregate_state_size,
                  duckdb_aggregate_init_t,
                  duckdb_aggregate_update_t,
                  duckdb_aggregate_combine_t,
                  duckdb_aggregate_finalize_t)>>(
      'duckdb_aggregate_function_set_functions');
  late final _duckdb_aggregate_function_set_functions =
      _duckdb_aggregate_function_set_functionsPtr.asFunction<
          void Function(
              duckdb_aggregate_function,
              duckdb_aggregate_state_size,
              duckdb_aggregate_init_t,
              duckdb_aggregate_update_t,
              duckdb_aggregate_combine_t,
              duckdb_aggregate_finalize_t)>();

  /// !
  /// Sets the state destructor callback of the aggregate function (optional)
  ///
  /// @param aggregate_function The aggregate function
  /// @param destroy state destroy callback
  void duckdb_aggregate_function_set_destructor(
    duckdb_aggregate_function aggregate_function,
    duckdb_aggregate_destroy_t destroy,
  ) {
    return _duckdb_aggregate_function_set_destructor(
      aggregate_function,
      destroy,
    );
  }

  late final _duckdb_aggregate_function_set_destructorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_aggregate_function, duckdb_aggregate_destroy_t)>>(
      'duckdb_aggregate_function_set_destructor');
  late final _duckdb_aggregate_function_set_destructor =
      _duckdb_aggregate_function_set_destructorPtr.asFunction<
          void Function(
              duckdb_aggregate_function, duckdb_aggregate_destroy_t)>();

  /// !
  /// Register the aggregate function object within the given connection.
  ///
  /// The function requires at least a name, functions and a return type.
  ///
  /// If the function is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// @param con The connection to register it in.
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_aggregate_function(
    duckdb_connection con,
    duckdb_aggregate_function aggregate_function,
  ) {
    return duckdb_state.fromValue(_duckdb_register_aggregate_function(
      con,
      aggregate_function,
    ));
  }

  late final _duckdb_register_aggregate_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection, duckdb_aggregate_function)>>(
      'duckdb_register_aggregate_function');
  late final _duckdb_register_aggregate_function =
      _duckdb_register_aggregate_functionPtr.asFunction<
          int Function(duckdb_connection, duckdb_aggregate_function)>();

  /// !
  /// Sets the NULL handling of the aggregate function to SPECIAL_HANDLING.
  ///
  /// @param aggregate_function The aggregate function
  void duckdb_aggregate_function_set_special_handling(
    duckdb_aggregate_function aggregate_function,
  ) {
    return _duckdb_aggregate_function_set_special_handling(
      aggregate_function,
    );
  }

  late final _duckdb_aggregate_function_set_special_handlingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_aggregate_function)>>(
          'duckdb_aggregate_function_set_special_handling');
  late final _duckdb_aggregate_function_set_special_handling =
      _duckdb_aggregate_function_set_special_handlingPtr
          .asFunction<void Function(duckdb_aggregate_function)>();

  /// !
  /// Assigns extra information to the scalar function that can be fetched during binding, etc.
  ///
  /// @param aggregate_function The aggregate function
  /// @param extra_info The extra information
  /// @param destroy The callback that will be called to destroy the bind data (if any)
  void duckdb_aggregate_function_set_extra_info(
    duckdb_aggregate_function aggregate_function,
    ffi.Pointer<ffi.Void> extra_info,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_aggregate_function_set_extra_info(
      aggregate_function,
      extra_info,
      destroy,
    );
  }

  late final _duckdb_aggregate_function_set_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_aggregate_function,
                  ffi.Pointer<ffi.Void>, duckdb_delete_callback_t)>>(
      'duckdb_aggregate_function_set_extra_info');
  late final _duckdb_aggregate_function_set_extra_info =
      _duckdb_aggregate_function_set_extra_infoPtr.asFunction<
          void Function(duckdb_aggregate_function, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_aggregate_function_set_extra_info`.
  ///
  /// @param info The info object
  /// @return The extra info
  ffi.Pointer<ffi.Void> duckdb_aggregate_function_get_extra_info(
    duckdb_function_info info,
  ) {
    return _duckdb_aggregate_function_get_extra_info(
      info,
    );
  }

  late final _duckdb_aggregate_function_get_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(duckdb_function_info)>>(
      'duckdb_aggregate_function_get_extra_info');
  late final _duckdb_aggregate_function_get_extra_info =
      _duckdb_aggregate_function_get_extra_infoPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Report that an error has occurred while executing the aggregate function.
  ///
  /// @param info The info object
  /// @param error The error message
  void duckdb_aggregate_function_set_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_aggregate_function_set_error(
      info,
      error,
    );
  }

  late final _duckdb_aggregate_function_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_aggregate_function_set_error');
  late final _duckdb_aggregate_function_set_error =
      _duckdb_aggregate_function_set_errorPtr.asFunction<
          void Function(duckdb_function_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates a new empty aggregate function set.
  ///
  /// The return value should be destroyed with `duckdb_destroy_aggregate_function_set`.
  ///
  /// @return The aggregate function set object.
  duckdb_aggregate_function_set duckdb_create_aggregate_function_set(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_create_aggregate_function_set(
      name,
    );
  }

  late final _duckdb_create_aggregate_function_setPtr = _lookup<
      ffi.NativeFunction<
          duckdb_aggregate_function_set Function(
              ffi.Pointer<ffi.Char>)>>('duckdb_create_aggregate_function_set');
  late final _duckdb_create_aggregate_function_set =
      _duckdb_create_aggregate_function_setPtr.asFunction<
          duckdb_aggregate_function_set Function(ffi.Pointer<ffi.Char>)>();

  /// !
  /// Destroys the given aggregate function set object.
  void duckdb_destroy_aggregate_function_set(
    ffi.Pointer<duckdb_aggregate_function_set> aggregate_function_set,
  ) {
    return _duckdb_destroy_aggregate_function_set(
      aggregate_function_set,
    );
  }

  late final _duckdb_destroy_aggregate_function_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_aggregate_function_set>)>>(
      'duckdb_destroy_aggregate_function_set');
  late final _duckdb_destroy_aggregate_function_set =
      _duckdb_destroy_aggregate_function_setPtr.asFunction<
          void Function(ffi.Pointer<duckdb_aggregate_function_set>)>();

  /// !
  /// Adds the aggregate function as a new overload to the aggregate function set.
  ///
  /// Returns DuckDBError if the function could not be added, for example if the overload already exists.
  ///
  /// @param set The aggregate function set
  /// @param function The function to add
  duckdb_state duckdb_add_aggregate_function_to_set(
    duckdb_aggregate_function_set set1,
    duckdb_aggregate_function function,
  ) {
    return duckdb_state.fromValue(_duckdb_add_aggregate_function_to_set(
      set1,
      function,
    ));
  }

  late final _duckdb_add_aggregate_function_to_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_aggregate_function_set, duckdb_aggregate_function)>>(
      'duckdb_add_aggregate_function_to_set');
  late final _duckdb_add_aggregate_function_to_set =
      _duckdb_add_aggregate_function_to_setPtr.asFunction<
          int Function(
              duckdb_aggregate_function_set, duckdb_aggregate_function)>();

  /// !
  /// Register the aggregate function set within the given connection.
  ///
  /// The set requires at least a single valid overload.
  ///
  /// If the set is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// @param con The connection to register it in.
  /// @param set The function set to register
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_aggregate_function_set(
    duckdb_connection con,
    duckdb_aggregate_function_set set1,
  ) {
    return duckdb_state.fromValue(_duckdb_register_aggregate_function_set(
      con,
      set1,
    ));
  }

  late final _duckdb_register_aggregate_function_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection, duckdb_aggregate_function_set)>>(
      'duckdb_register_aggregate_function_set');
  late final _duckdb_register_aggregate_function_set =
      _duckdb_register_aggregate_function_setPtr.asFunction<
          int Function(duckdb_connection, duckdb_aggregate_function_set)>();

  /// !
  /// Creates a new empty table function.
  ///
  /// The return value should be destroyed with `duckdb_destroy_table_function`.
  ///
  /// @return The table function object.
  duckdb_table_function duckdb_create_table_function() {
    return _duckdb_create_table_function();
  }

  late final _duckdb_create_table_functionPtr =
      _lookup<ffi.NativeFunction<duckdb_table_function Function()>>(
          'duckdb_create_table_function');
  late final _duckdb_create_table_function = _duckdb_create_table_functionPtr
      .asFunction<duckdb_table_function Function()>();

  /// !
  /// Destroys the given table function object.
  ///
  /// @param table_function The table function to destroy
  void duckdb_destroy_table_function(
    ffi.Pointer<duckdb_table_function> table_function,
  ) {
    return _duckdb_destroy_table_function(
      table_function,
    );
  }

  late final _duckdb_destroy_table_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_table_function>)>>(
      'duckdb_destroy_table_function');
  late final _duckdb_destroy_table_function = _duckdb_destroy_table_functionPtr
      .asFunction<void Function(ffi.Pointer<duckdb_table_function>)>();

  /// !
  /// Sets the name of the given table function.
  ///
  /// @param table_function The table function
  /// @param name The name of the table function
  void duckdb_table_function_set_name(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_table_function_set_name(
      table_function,
      name,
    );
  }

  late final _duckdb_table_function_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              ffi.Pointer<ffi.Char>)>>('duckdb_table_function_set_name');
  late final _duckdb_table_function_set_name =
      _duckdb_table_function_set_namePtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Adds a parameter to the table function.
  ///
  /// @param table_function The table function.
  /// @param type The parameter type. Cannot contain INVALID.
  void duckdb_table_function_add_parameter(
    duckdb_table_function table_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_table_function_add_parameter(
      table_function,
      type,
    );
  }

  late final _duckdb_table_function_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_logical_type)>>('duckdb_table_function_add_parameter');
  late final _duckdb_table_function_add_parameter =
      _duckdb_table_function_add_parameterPtr.asFunction<
          void Function(duckdb_table_function, duckdb_logical_type)>();

  /// !
  /// Adds a named parameter to the table function.
  ///
  /// @param table_function The table function.
  /// @param name The parameter name.
  /// @param type The parameter type. Cannot contain INVALID.
  void duckdb_table_function_add_named_parameter(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Char> name,
    duckdb_logical_type type,
  ) {
    return _duckdb_table_function_add_named_parameter(
      table_function,
      name,
      type,
    );
  }

  late final _duckdb_table_function_add_named_parameterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_table_function, ffi.Pointer<ffi.Char>,
                  duckdb_logical_type)>>(
      'duckdb_table_function_add_named_parameter');
  late final _duckdb_table_function_add_named_parameter =
      _duckdb_table_function_add_named_parameterPtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Char>,
              duckdb_logical_type)>();

  /// !
  /// Assigns extra information to the table function that can be fetched during binding, etc.
  ///
  /// @param table_function The table function
  /// @param extra_info The extra information
  /// @param destroy The callback that will be called to destroy the bind data (if any)
  void duckdb_table_function_set_extra_info(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Void> extra_info,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_table_function_set_extra_info(
      table_function,
      extra_info,
      destroy,
    );
  }

  late final _duckdb_table_function_set_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_table_function, ffi.Pointer<ffi.Void>,
                  duckdb_delete_callback_t)>>(
      'duckdb_table_function_set_extra_info');
  late final _duckdb_table_function_set_extra_info =
      _duckdb_table_function_set_extra_infoPtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Sets the bind function of the table function.
  ///
  /// @param table_function The table function
  /// @param bind The bind function
  void duckdb_table_function_set_bind(
    duckdb_table_function table_function,
    duckdb_table_function_bind_t bind,
  ) {
    return _duckdb_table_function_set_bind(
      table_function,
      bind,
    );
  }

  late final _duckdb_table_function_set_bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_bind_t)>>('duckdb_table_function_set_bind');
  late final _duckdb_table_function_set_bind =
      _duckdb_table_function_set_bindPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_bind_t)>();

  /// !
  /// Sets the init function of the table function.
  ///
  /// @param table_function The table function
  /// @param init The init function
  void duckdb_table_function_set_init(
    duckdb_table_function table_function,
    duckdb_table_function_init_t init,
  ) {
    return _duckdb_table_function_set_init(
      table_function,
      init,
    );
  }

  late final _duckdb_table_function_set_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_init_t)>>('duckdb_table_function_set_init');
  late final _duckdb_table_function_set_init =
      _duckdb_table_function_set_initPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_init_t)>();

  /// !
  /// Sets the thread-local init function of the table function.
  ///
  /// @param table_function The table function
  /// @param init The init function
  void duckdb_table_function_set_local_init(
    duckdb_table_function table_function,
    duckdb_table_function_init_t init,
  ) {
    return _duckdb_table_function_set_local_init(
      table_function,
      init,
    );
  }

  late final _duckdb_table_function_set_local_initPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_table_function, duckdb_table_function_init_t)>>(
      'duckdb_table_function_set_local_init');
  late final _duckdb_table_function_set_local_init =
      _duckdb_table_function_set_local_initPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_init_t)>();

  /// !
  /// Sets the main function of the table function.
  ///
  /// @param table_function The table function
  /// @param function The function
  void duckdb_table_function_set_function(
    duckdb_table_function table_function,
    duckdb_table_function_t function,
  ) {
    return _duckdb_table_function_set_function(
      table_function,
      function,
    );
  }

  late final _duckdb_table_function_set_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_t)>>('duckdb_table_function_set_function');
  late final _duckdb_table_function_set_function =
      _duckdb_table_function_set_functionPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_t)>();

  /// !
  /// Sets whether or not the given table function supports projection pushdown.
  ///
  /// If this is set to true, the system will provide a list of all required columns in the `init` stage through
  /// the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
  /// If this is set to false (the default), the system will expect all columns to be projected.
  ///
  /// @param table_function The table function
  /// @param pushdown True if the table function supports projection pushdown, false otherwise.
  void duckdb_table_function_supports_projection_pushdown(
    duckdb_table_function table_function,
    bool pushdown,
  ) {
    return _duckdb_table_function_supports_projection_pushdown(
      table_function,
      pushdown,
    );
  }

  late final _duckdb_table_function_supports_projection_pushdownPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(duckdb_table_function, ffi.Bool)>>(
      'duckdb_table_function_supports_projection_pushdown');
  late final _duckdb_table_function_supports_projection_pushdown =
      _duckdb_table_function_supports_projection_pushdownPtr
          .asFunction<void Function(duckdb_table_function, bool)>();

  /// !
  /// Register the table function object within the given connection.
  ///
  /// The function requires at least a name, a bind function, an init function and a main function.
  ///
  /// If the function is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// @param con The connection to register it in.
  /// @param function The function pointer
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_table_function(
    duckdb_connection con,
    duckdb_table_function function,
  ) {
    return duckdb_state.fromValue(_duckdb_register_table_function(
      con,
      function,
    ));
  }

  late final _duckdb_register_table_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection,
              duckdb_table_function)>>('duckdb_register_table_function');
  late final _duckdb_register_table_function =
      _duckdb_register_table_functionPtr
          .asFunction<int Function(duckdb_connection, duckdb_table_function)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
  ///
  /// @param info The info object
  /// @return The extra info
  ffi.Pointer<ffi.Void> duckdb_bind_get_extra_info(
    duckdb_bind_info info,
  ) {
    return _duckdb_bind_get_extra_info(
      info,
    );
  }

  late final _duckdb_bind_get_extra_infoPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_bind_info)>>(
      'duckdb_bind_get_extra_info');
  late final _duckdb_bind_get_extra_info = _duckdb_bind_get_extra_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_bind_info)>();

  /// !
  /// Adds a result column to the output of the table function.
  ///
  /// @param info The table function's bind info.
  /// @param name The column name.
  /// @param type The logical column type.
  void duckdb_bind_add_result_column(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> name,
    duckdb_logical_type type,
  ) {
    return _duckdb_bind_add_result_column(
      info,
      name,
      type,
    );
  }

  late final _duckdb_bind_add_result_columnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, ffi.Pointer<ffi.Char>,
              duckdb_logical_type)>>('duckdb_bind_add_result_column');
  late final _duckdb_bind_add_result_column =
      _duckdb_bind_add_result_columnPtr.asFunction<
          void Function(
              duckdb_bind_info, ffi.Pointer<ffi.Char>, duckdb_logical_type)>();

  /// !
  /// Retrieves the number of regular (non-named) parameters to the function.
  ///
  /// @param info The info object
  /// @return The number of parameters
  int duckdb_bind_get_parameter_count(
    duckdb_bind_info info,
  ) {
    return _duckdb_bind_get_parameter_count(
      info,
    );
  }

  late final _duckdb_bind_get_parameter_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_bind_info)>>(
          'duckdb_bind_get_parameter_count');
  late final _duckdb_bind_get_parameter_count =
      _duckdb_bind_get_parameter_countPtr
          .asFunction<int Function(duckdb_bind_info)>();

  /// !
  /// Retrieves the parameter at the given index.
  ///
  /// The result must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param info The info object
  /// @param index The index of the parameter to get
  /// @return The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_bind_get_parameter(
    duckdb_bind_info info,
    int index,
  ) {
    return _duckdb_bind_get_parameter(
      info,
      index,
    );
  }

  late final _duckdb_bind_get_parameterPtr = _lookup<
          ffi.NativeFunction<duckdb_value Function(duckdb_bind_info, idx_t)>>(
      'duckdb_bind_get_parameter');
  late final _duckdb_bind_get_parameter = _duckdb_bind_get_parameterPtr
      .asFunction<duckdb_value Function(duckdb_bind_info, int)>();

  /// !
  /// Retrieves a named parameter with the given name.
  ///
  /// The result must be destroyed with `duckdb_destroy_value`.
  ///
  /// @param info The info object
  /// @param name The name of the parameter
  /// @return The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_bind_get_named_parameter(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_bind_get_named_parameter(
      info,
      name,
    );
  }

  late final _duckdb_bind_get_named_parameterPtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_bind_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_get_named_parameter');
  late final _duckdb_bind_get_named_parameter =
      _duckdb_bind_get_named_parameterPtr.asFunction<
          duckdb_value Function(duckdb_bind_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.
  ///
  /// @param info The info object
  /// @param bind_data The bind data object.
  /// @param destroy The callback that will be called to destroy the bind data (if any)
  void duckdb_bind_set_bind_data(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Void> bind_data,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_bind_set_bind_data(
      info,
      bind_data,
      destroy,
    );
  }

  late final _duckdb_bind_set_bind_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_bind_set_bind_data');
  late final _duckdb_bind_set_bind_data =
      _duckdb_bind_set_bind_dataPtr.asFunction<
          void Function(duckdb_bind_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Sets the cardinality estimate for the table function, used for optimization.
  ///
  /// @param info The bind data object.
  /// @param is_exact Whether or not the cardinality estimate is exact, or an approximation
  void duckdb_bind_set_cardinality(
    duckdb_bind_info info,
    int cardinality,
    bool is_exact,
  ) {
    return _duckdb_bind_set_cardinality(
      info,
      cardinality,
      is_exact,
    );
  }

  late final _duckdb_bind_set_cardinalityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, idx_t,
              ffi.Bool)>>('duckdb_bind_set_cardinality');
  late final _duckdb_bind_set_cardinality = _duckdb_bind_set_cardinalityPtr
      .asFunction<void Function(duckdb_bind_info, int, bool)>();

  /// !
  /// Report that an error has occurred while calling bind.
  ///
  /// @param info The info object
  /// @param error The error message
  void duckdb_bind_set_error(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_bind_set_error(
      info,
      error,
    );
  }

  late final _duckdb_bind_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_set_error');
  late final _duckdb_bind_set_error = _duckdb_bind_set_errorPtr
      .asFunction<void Function(duckdb_bind_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
  ///
  /// @param info The info object
  /// @return The extra info
  ffi.Pointer<ffi.Void> duckdb_init_get_extra_info(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_extra_info(
      info,
    );
  }

  late final _duckdb_init_get_extra_infoPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>>(
      'duckdb_init_get_extra_info');
  late final _duckdb_init_get_extra_info = _duckdb_init_get_extra_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>();

  /// !
  /// Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
  ///
  /// Note that the bind data should be considered as read-only.
  /// For tracking state, use the init data instead.
  ///
  /// @param info The info object
  /// @return The bind data object
  ffi.Pointer<ffi.Void> duckdb_init_get_bind_data(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_bind_data(
      info,
    );
  }

  late final _duckdb_init_get_bind_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>>(
      'duckdb_init_get_bind_data');
  late final _duckdb_init_get_bind_data = _duckdb_init_get_bind_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>();

  /// !
  /// Sets the user-provided init data in the init object. This object can be retrieved again during execution.
  ///
  /// @param info The info object
  /// @param init_data The init data object.
  /// @param destroy The callback that will be called to destroy the init data (if any)
  void duckdb_init_set_init_data(
    duckdb_init_info info,
    ffi.Pointer<ffi.Void> init_data,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_init_set_init_data(
      info,
      init_data,
      destroy,
    );
  }

  late final _duckdb_init_set_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_init_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_init_set_init_data');
  late final _duckdb_init_set_init_data =
      _duckdb_init_set_init_dataPtr.asFunction<
          void Function(duckdb_init_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Returns the number of projected columns.
  ///
  /// This function must be used if projection pushdown is enabled to figure out which columns to emit.
  ///
  /// @param info The info object
  /// @return The number of projected columns.
  int duckdb_init_get_column_count(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_column_count(
      info,
    );
  }

  late final _duckdb_init_get_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_init_info)>>(
          'duckdb_init_get_column_count');
  late final _duckdb_init_get_column_count = _duckdb_init_get_column_countPtr
      .asFunction<int Function(duckdb_init_info)>();

  /// !
  /// Returns the column index of the projected column at the specified position.
  ///
  /// This function must be used if projection pushdown is enabled to figure out which columns to emit.
  ///
  /// @param info The info object
  /// @param column_index The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
  /// @return The column index of the projected column.
  int duckdb_init_get_column_index(
    duckdb_init_info info,
    int column_index,
  ) {
    return _duckdb_init_get_column_index(
      info,
      column_index,
    );
  }

  late final _duckdb_init_get_column_indexPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_init_info, idx_t)>>(
          'duckdb_init_get_column_index');
  late final _duckdb_init_get_column_index = _duckdb_init_get_column_indexPtr
      .asFunction<int Function(duckdb_init_info, int)>();

  /// !
  /// Sets how many threads can process this table function in parallel (default: 1)
  ///
  /// @param info The info object
  /// @param max_threads The maximum amount of threads that can process this table function
  void duckdb_init_set_max_threads(
    duckdb_init_info info,
    int max_threads,
  ) {
    return _duckdb_init_set_max_threads(
      info,
      max_threads,
    );
  }

  late final _duckdb_init_set_max_threadsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_init_info, idx_t)>>(
          'duckdb_init_set_max_threads');
  late final _duckdb_init_set_max_threads = _duckdb_init_set_max_threadsPtr
      .asFunction<void Function(duckdb_init_info, int)>();

  /// !
  /// Report that an error has occurred while calling init.
  ///
  /// @param info The info object
  /// @param error The error message
  void duckdb_init_set_error(
    duckdb_init_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_init_set_error(
      info,
      error,
    );
  }

  late final _duckdb_init_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_init_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_init_set_error');
  late final _duckdb_init_set_error = _duckdb_init_set_errorPtr
      .asFunction<void Function(duckdb_init_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
  ///
  /// @param info The info object
  /// @return The extra info
  ffi.Pointer<ffi.Void> duckdb_function_get_extra_info(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_extra_info(
      info,
    );
  }

  late final _duckdb_function_get_extra_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_extra_info');
  late final _duckdb_function_get_extra_info =
      _duckdb_function_get_extra_infoPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
  ///
  /// Note that the bind data should be considered as read-only.
  /// For tracking state, use the init data instead.
  ///
  /// @param info The info object
  /// @return The bind data object
  ffi.Pointer<ffi.Void> duckdb_function_get_bind_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_bind_data(
      info,
    );
  }

  late final _duckdb_function_get_bind_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_bind_data');
  late final _duckdb_function_get_bind_data = _duckdb_function_get_bind_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the init data set by `duckdb_init_set_init_data` during the init.
  ///
  /// @param info The info object
  /// @return The init data object
  ffi.Pointer<ffi.Void> duckdb_function_get_init_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_init_data(
      info,
    );
  }

  late final _duckdb_function_get_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_init_data');
  late final _duckdb_function_get_init_data = _duckdb_function_get_init_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.
  ///
  /// @param info The info object
  /// @return The init data object
  ffi.Pointer<ffi.Void> duckdb_function_get_local_init_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_local_init_data(
      info,
    );
  }

  late final _duckdb_function_get_local_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_local_init_data');
  late final _duckdb_function_get_local_init_data =
      _duckdb_function_get_local_init_dataPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Report that an error has occurred while executing the function.
  ///
  /// @param info The info object
  /// @param error The error message
  void duckdb_function_set_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_function_set_error(
      info,
      error,
    );
  }

  late final _duckdb_function_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_function_set_error');
  late final _duckdb_function_set_error = _duckdb_function_set_errorPtr
      .asFunction<void Function(duckdb_function_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Add a replacement scan definition to the specified database.
  ///
  /// @param db The database object to add the replacement scan to
  /// @param replacement The replacement scan callback
  /// @param extra_data Extra data that is passed back into the specified callback
  /// @param delete_callback The delete callback to call on the extra data, if any
  void duckdb_add_replacement_scan(
    duckdb_database db,
    duckdb_replacement_callback_t replacement,
    ffi.Pointer<ffi.Void> extra_data,
    duckdb_delete_callback_t delete_callback,
  ) {
    return _duckdb_add_replacement_scan(
      db,
      replacement,
      extra_data,
      delete_callback,
    );
  }

  late final _duckdb_add_replacement_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              duckdb_database,
              duckdb_replacement_callback_t,
              ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_add_replacement_scan');
  late final _duckdb_add_replacement_scan =
      _duckdb_add_replacement_scanPtr.asFunction<
          void Function(duckdb_database, duckdb_replacement_callback_t,
              ffi.Pointer<ffi.Void>, duckdb_delete_callback_t)>();

  /// !
  /// Sets the replacement function name. If this function is called in the replacement callback,
  /// the replacement scan is performed. If it is not called, the replacement callback is not performed.
  ///
  /// @param info The info object
  /// @param function_name The function name to substitute.
  void duckdb_replacement_scan_set_function_name(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> function_name,
  ) {
    return _duckdb_replacement_scan_set_function_name(
      info,
      function_name,
    );
  }

  late final _duckdb_replacement_scan_set_function_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>>(
      'duckdb_replacement_scan_set_function_name');
  late final _duckdb_replacement_scan_set_function_name =
      _duckdb_replacement_scan_set_function_namePtr.asFunction<
          void Function(duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Adds a parameter to the replacement scan function.
  ///
  /// @param info The info object
  /// @param parameter The parameter to add.
  void duckdb_replacement_scan_add_parameter(
    duckdb_replacement_scan_info info,
    duckdb_value parameter,
  ) {
    return _duckdb_replacement_scan_add_parameter(
      info,
      parameter,
    );
  }

  late final _duckdb_replacement_scan_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_replacement_scan_info,
              duckdb_value)>>('duckdb_replacement_scan_add_parameter');
  late final _duckdb_replacement_scan_add_parameter =
      _duckdb_replacement_scan_add_parameterPtr.asFunction<
          void Function(duckdb_replacement_scan_info, duckdb_value)>();

  /// !
  /// Report that an error has occurred while executing the replacement scan.
  ///
  /// @param info The info object
  /// @param error The error message
  void duckdb_replacement_scan_set_error(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_replacement_scan_set_error(
      info,
      error,
    );
  }

  late final _duckdb_replacement_scan_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_replacement_scan_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_replacement_scan_set_error');
  late final _duckdb_replacement_scan_set_error =
      _duckdb_replacement_scan_set_errorPtr.asFunction<
          void Function(duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Returns the root node of the profiling information. Returns nullptr, if profiling is not enabled.
  ///
  /// @param connection A connection object.
  /// @return A profiling information object.
  duckdb_profiling_info duckdb_get_profiling_info(
    duckdb_connection connection,
  ) {
    return _duckdb_get_profiling_info(
      connection,
    );
  }

  late final _duckdb_get_profiling_infoPtr = _lookup<
          ffi
          .NativeFunction<duckdb_profiling_info Function(duckdb_connection)>>(
      'duckdb_get_profiling_info');
  late final _duckdb_get_profiling_info = _duckdb_get_profiling_infoPtr
      .asFunction<duckdb_profiling_info Function(duckdb_connection)>();

  /// !
  /// Returns the value of the metric of the current profiling info node. Returns nullptr, if the metric does
  /// not exist or is not enabled. Currently, the value holds a string, and you can retrieve the string
  /// by calling the corresponding function: char *duckdb_get_varchar(duckdb_value value).
  ///
  /// @param info A profiling information object.
  /// @param key The name of the requested metric.
  /// @return The value of the metric. Must be freed with `duckdb_destroy_value`
  duckdb_value duckdb_profiling_info_get_value(
    duckdb_profiling_info info,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _duckdb_profiling_info_get_value(
      info,
      key,
    );
  }

  late final _duckdb_profiling_info_get_valuePtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_profiling_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_profiling_info_get_value');
  late final _duckdb_profiling_info_get_value =
      _duckdb_profiling_info_get_valuePtr.asFunction<
          duckdb_value Function(
              duckdb_profiling_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Returns the key-value metric map of this profiling node as a MAP duckdb_value.
  /// The individual elements are accessible via the duckdb_value MAP functions.
  ///
  /// @param info A profiling information object.
  /// @return The key-value metric map as a MAP duckdb_value.
  duckdb_value duckdb_profiling_info_get_metrics(
    duckdb_profiling_info info,
  ) {
    return _duckdb_profiling_info_get_metrics(
      info,
    );
  }

  late final _duckdb_profiling_info_get_metricsPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(duckdb_profiling_info)>>(
          'duckdb_profiling_info_get_metrics');
  late final _duckdb_profiling_info_get_metrics =
      _duckdb_profiling_info_get_metricsPtr
          .asFunction<duckdb_value Function(duckdb_profiling_info)>();

  /// !
  /// Returns the number of children in the current profiling info node.
  ///
  /// @param info A profiling information object.
  /// @return The number of children in the current node.
  int duckdb_profiling_info_get_child_count(
    duckdb_profiling_info info,
  ) {
    return _duckdb_profiling_info_get_child_count(
      info,
    );
  }

  late final _duckdb_profiling_info_get_child_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_profiling_info)>>(
          'duckdb_profiling_info_get_child_count');
  late final _duckdb_profiling_info_get_child_count =
      _duckdb_profiling_info_get_child_countPtr
          .asFunction<int Function(duckdb_profiling_info)>();

  /// !
  /// Returns the child node at the specified index.
  ///
  /// @param info A profiling information object.
  /// @param index The index of the child node.
  /// @return The child node at the specified index.
  duckdb_profiling_info duckdb_profiling_info_get_child(
    duckdb_profiling_info info,
    int index,
  ) {
    return _duckdb_profiling_info_get_child(
      info,
      index,
    );
  }

  late final _duckdb_profiling_info_get_childPtr = _lookup<
      ffi.NativeFunction<
          duckdb_profiling_info Function(duckdb_profiling_info,
              idx_t)>>('duckdb_profiling_info_get_child');
  late final _duckdb_profiling_info_get_child =
      _duckdb_profiling_info_get_childPtr.asFunction<
          duckdb_profiling_info Function(duckdb_profiling_info, int)>();

  /// !
  /// Creates an appender object.
  ///
  /// Note that the object must be destroyed with `duckdb_appender_destroy`.
  ///
  /// @param connection The connection context to create the appender in.
  /// @param schema The schema of the table to append to, or `nullptr` for the default schema.
  /// @param table The table name to append to.
  /// @param out_appender The resulting appender object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_create(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> schema,
    ffi.Pointer<ffi.Char> table,
    ffi.Pointer<duckdb_appender> out_appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_create(
      connection,
      schema,
      table,
      out_appender,
    ));
  }

  late final _duckdb_appender_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_appender>)>>('duckdb_appender_create');
  late final _duckdb_appender_create = _duckdb_appender_createPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_appender>)>();

  /// !
  /// Creates an appender object.
  ///
  /// Note that the object must be destroyed with `duckdb_appender_destroy`.
  ///
  /// @param connection The connection context to create the appender in.
  /// @param catalog The catalog of the table to append to, or `nullptr` for the default catalog.
  /// @param schema The schema of the table to append to, or `nullptr` for the default schema.
  /// @param table The table name to append to.
  /// @param out_appender The resulting appender object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_create_ext(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> catalog,
    ffi.Pointer<ffi.Char> schema,
    ffi.Pointer<ffi.Char> table,
    ffi.Pointer<duckdb_appender> out_appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_create_ext(
      connection,
      catalog,
      schema,
      table,
      out_appender,
    ));
  }

  late final _duckdb_appender_create_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_appender>)>>('duckdb_appender_create_ext');
  late final _duckdb_appender_create_ext =
      _duckdb_appender_create_extPtr.asFunction<
          int Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_appender>)>();

  /// !
  /// Returns the number of columns that belong to the appender.
  /// If there is no active column list, then this equals the table's physical columns.
  ///
  /// @param appender The appender to get the column count from.
  /// @return The number of columns in the data chunks.
  int duckdb_appender_column_count(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_column_count(
      appender,
    );
  }

  late final _duckdb_appender_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_appender)>>(
          'duckdb_appender_column_count');
  late final _duckdb_appender_column_count = _duckdb_appender_column_countPtr
      .asFunction<int Function(duckdb_appender)>();

  /// !
  /// Returns the type of the column at the specified index. This is either a type in the active column list, or the same type
  /// as a column in the receiving table.
  ///
  /// Note: The resulting type must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// @param appender The appender to get the column type from.
  /// @param col_idx The index of the column to get the type of.
  /// @return The `duckdb_logical_type` of the column.
  duckdb_logical_type duckdb_appender_column_type(
    duckdb_appender appender,
    int col_idx,
  ) {
    return _duckdb_appender_column_type(
      appender,
      col_idx,
    );
  }

  late final _duckdb_appender_column_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_appender, idx_t)>>('duckdb_appender_column_type');
  late final _duckdb_appender_column_type = _duckdb_appender_column_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_appender, int)>();

  /// !
  /// Returns the error message associated with the given appender.
  /// If the appender has no error message, this returns `nullptr` instead.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
  ///
  /// @param appender The appender to get the error from.
  /// @return The error message, or `nullptr` if there is none.
  ffi.Pointer<ffi.Char> duckdb_appender_error(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_error(
      appender,
    );
  }

  late final _duckdb_appender_errorPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_appender)>>(
      'duckdb_appender_error');
  late final _duckdb_appender_error = _duckdb_appender_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_appender)>();

  /// !
  /// Flush the appender to the table, forcing the cache of the appender to be cleared. If flushing the data triggers a
  /// constraint violation or any other error, then all data is invalidated, and this function returns DuckDBError.
  /// It is not possible to append more values. Call duckdb_appender_error to obtain the error message followed by
  /// duckdb_appender_destroy to destroy the invalidated appender.
  ///
  /// @param appender The appender to flush.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_flush(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_flush(
      appender,
    ));
  }

  late final _duckdb_appender_flushPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_appender_flush');
  late final _duckdb_appender_flush =
      _duckdb_appender_flushPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Closes the appender by flushing all intermediate states and closing it for further appends. If flushing the data
  /// triggers a constraint violation or any other error, then all data is invalidated, and this function returns DuckDBError.
  /// Call duckdb_appender_error to obtain the error message followed by duckdb_appender_destroy to destroy the invalidated
  /// appender.
  ///
  /// @param appender The appender to flush and close.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_close(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_close(
      appender,
    ));
  }

  late final _duckdb_appender_closePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_appender_close');
  late final _duckdb_appender_close =
      _duckdb_appender_closePtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Closes the appender by flushing all intermediate states to the table and destroying it. By destroying it, this function
  /// de-allocates all memory associated with the appender. If flushing the data triggers a constraint violation,
  /// then all data is invalidated, and this function returns DuckDBError. Due to the destruction of the appender, it is no
  /// longer possible to obtain the specific error message with duckdb_appender_error. Therefore, call duckdb_appender_close
  /// before destroying the appender, if you need insights into the specific error.
  ///
  /// @param appender The appender to flush, close and destroy.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_destroy(
    ffi.Pointer<duckdb_appender> appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_destroy(
      appender,
    ));
  }

  late final _duckdb_appender_destroyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<duckdb_appender>)>>('duckdb_appender_destroy');
  late final _duckdb_appender_destroy = _duckdb_appender_destroyPtr
      .asFunction<int Function(ffi.Pointer<duckdb_appender>)>();

  /// !
  /// Appends a column to the active column list of the appender. Immediately flushes all previous data.
  ///
  /// The active column list specifies all columns that are expected when flushing the data. Any non-active columns are filled
  /// with their default values, or NULL.
  ///
  /// @param appender The appender to add the column to.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_add_column(
    duckdb_appender appender,
    ffi.Pointer<ffi.Char> name,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_add_column(
      appender,
      name,
    ));
  }

  late final _duckdb_appender_add_columnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_appender,
              ffi.Pointer<ffi.Char>)>>('duckdb_appender_add_column');
  late final _duckdb_appender_add_column = _duckdb_appender_add_columnPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Removes all columns from the active column list of the appender, resetting the appender to treat all columns as active.
  /// Immediately flushes all previous data.
  ///
  /// @param appender The appender to clear the columns from.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_clear_columns(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_clear_columns(
      appender,
    ));
  }

  late final _duckdb_appender_clear_columnsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_appender_clear_columns');
  late final _duckdb_appender_clear_columns = _duckdb_appender_clear_columnsPtr
      .asFunction<int Function(duckdb_appender)>();

  /// !
  /// A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
  duckdb_state duckdb_appender_begin_row(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_begin_row(
      appender,
    ));
  }

  late final _duckdb_appender_begin_rowPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_appender_begin_row');
  late final _duckdb_appender_begin_row =
      _duckdb_appender_begin_rowPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Finish the current row of appends. After end_row is called, the next row can be appended.
  ///
  /// @param appender The appender.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_appender_end_row(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_appender_end_row(
      appender,
    ));
  }

  late final _duckdb_appender_end_rowPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_appender_end_row');
  late final _duckdb_appender_end_row =
      _duckdb_appender_end_rowPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Append a DEFAULT value (NULL if DEFAULT not available for column) to the appender.
  duckdb_state duckdb_append_default(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_append_default(
      appender,
    ));
  }

  late final _duckdb_append_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_append_default');
  late final _duckdb_append_default =
      _duckdb_append_defaultPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Append a DEFAULT value, at the specified row and column, (NULL if DEFAULT not available for column) to the chunk created
  /// from the specified appender. The default value of the column must be a constant value. Non-deterministic expressions
  /// like nextval('seq') or random() are not supported.
  ///
  /// @param appender The appender to get the default value from.
  /// @param chunk The data chunk to append the default value to.
  /// @param col The chunk column index to append the default value to.
  /// @param row The chunk row index to append the default value to.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_append_default_to_chunk(
    duckdb_appender appender,
    duckdb_data_chunk chunk,
    Dartidx_t col,
    Dartidx_t row,
  ) {
    return duckdb_state.fromValue(_duckdb_append_default_to_chunk(
      appender,
      chunk,
      col,
      row,
    ));
  }

  late final _duckdb_append_default_to_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_appender, duckdb_data_chunk, idx_t,
              idx_t)>>('duckdb_append_default_to_chunk');
  late final _duckdb_append_default_to_chunk =
      _duckdb_append_default_to_chunkPtr.asFunction<
          int Function(duckdb_appender, duckdb_data_chunk, int, int)>();

  /// !
  /// Append a bool value to the appender.
  duckdb_state duckdb_append_bool(
    duckdb_appender appender,
    bool value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_bool(
      appender,
      value,
    ));
  }

  late final _duckdb_append_boolPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(duckdb_appender, ffi.Bool)>>(
      'duckdb_append_bool');
  late final _duckdb_append_bool =
      _duckdb_append_boolPtr.asFunction<int Function(duckdb_appender, bool)>();

  /// !
  /// Append an int8_t value to the appender.
  duckdb_state duckdb_append_int8(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_int8(
      appender,
      value,
    ));
  }

  late final _duckdb_append_int8Ptr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(duckdb_appender, ffi.Int8)>>(
      'duckdb_append_int8');
  late final _duckdb_append_int8 =
      _duckdb_append_int8Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int16_t value to the appender.
  duckdb_state duckdb_append_int16(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_int16(
      appender,
      value,
    ));
  }

  late final _duckdb_append_int16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Int16)>>('duckdb_append_int16');
  late final _duckdb_append_int16 =
      _duckdb_append_int16Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int32_t value to the appender.
  duckdb_state duckdb_append_int32(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_int32(
      appender,
      value,
    ));
  }

  late final _duckdb_append_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Int32)>>('duckdb_append_int32');
  late final _duckdb_append_int32 =
      _duckdb_append_int32Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int64_t value to the appender.
  duckdb_state duckdb_append_int64(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_int64(
      appender,
      value,
    ));
  }

  late final _duckdb_append_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Int64)>>('duckdb_append_int64');
  late final _duckdb_append_int64 =
      _duckdb_append_int64Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a duckdb_hugeint value to the appender.
  duckdb_state duckdb_append_hugeint(
    duckdb_appender appender,
    duckdb_hugeint value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_hugeint(
      appender,
      value,
    ));
  }

  late final _duckdb_append_hugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_hugeint)>>('duckdb_append_hugeint');
  late final _duckdb_append_hugeint = _duckdb_append_hugeintPtr
      .asFunction<int Function(duckdb_appender, duckdb_hugeint)>();

  /// !
  /// Append a uint8_t value to the appender.
  duckdb_state duckdb_append_uint8(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_uint8(
      appender,
      value,
    ));
  }

  late final _duckdb_append_uint8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Uint8)>>('duckdb_append_uint8');
  late final _duckdb_append_uint8 =
      _duckdb_append_uint8Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint16_t value to the appender.
  duckdb_state duckdb_append_uint16(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_uint16(
      appender,
      value,
    ));
  }

  late final _duckdb_append_uint16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Uint16)>>('duckdb_append_uint16');
  late final _duckdb_append_uint16 =
      _duckdb_append_uint16Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint32_t value to the appender.
  duckdb_state duckdb_append_uint32(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_uint32(
      appender,
      value,
    ));
  }

  late final _duckdb_append_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Uint32)>>('duckdb_append_uint32');
  late final _duckdb_append_uint32 =
      _duckdb_append_uint32Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint64_t value to the appender.
  duckdb_state duckdb_append_uint64(
    duckdb_appender appender,
    int value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_uint64(
      appender,
      value,
    ));
  }

  late final _duckdb_append_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Uint64)>>('duckdb_append_uint64');
  late final _duckdb_append_uint64 =
      _duckdb_append_uint64Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a duckdb_uhugeint value to the appender.
  duckdb_state duckdb_append_uhugeint(
    duckdb_appender appender,
    duckdb_uhugeint value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_uhugeint(
      appender,
      value,
    ));
  }

  late final _duckdb_append_uhugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_uhugeint)>>('duckdb_append_uhugeint');
  late final _duckdb_append_uhugeint = _duckdb_append_uhugeintPtr
      .asFunction<int Function(duckdb_appender, duckdb_uhugeint)>();

  /// !
  /// Append a float value to the appender.
  duckdb_state duckdb_append_float(
    duckdb_appender appender,
    double value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_float(
      appender,
      value,
    ));
  }

  late final _duckdb_append_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Float)>>('duckdb_append_float');
  late final _duckdb_append_float = _duckdb_append_floatPtr
      .asFunction<int Function(duckdb_appender, double)>();

  /// !
  /// Append a double value to the appender.
  duckdb_state duckdb_append_double(
    duckdb_appender appender,
    double value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_double(
      appender,
      value,
    ));
  }

  late final _duckdb_append_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, ffi.Double)>>('duckdb_append_double');
  late final _duckdb_append_double = _duckdb_append_doublePtr
      .asFunction<int Function(duckdb_appender, double)>();

  /// !
  /// Append a duckdb_date value to the appender.
  duckdb_state duckdb_append_date(
    duckdb_appender appender,
    duckdb_date value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_date(
      appender,
      value,
    ));
  }

  late final _duckdb_append_datePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_date)>>('duckdb_append_date');
  late final _duckdb_append_date = _duckdb_append_datePtr
      .asFunction<int Function(duckdb_appender, duckdb_date)>();

  /// !
  /// Append a duckdb_time value to the appender.
  duckdb_state duckdb_append_time(
    duckdb_appender appender,
    duckdb_time value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_time(
      appender,
      value,
    ));
  }

  late final _duckdb_append_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_time)>>('duckdb_append_time');
  late final _duckdb_append_time = _duckdb_append_timePtr
      .asFunction<int Function(duckdb_appender, duckdb_time)>();

  /// !
  /// Append a duckdb_timestamp value to the appender.
  duckdb_state duckdb_append_timestamp(
    duckdb_appender appender,
    duckdb_timestamp value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_timestamp(
      appender,
      value,
    ));
  }

  late final _duckdb_append_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_timestamp)>>('duckdb_append_timestamp');
  late final _duckdb_append_timestamp = _duckdb_append_timestampPtr
      .asFunction<int Function(duckdb_appender, duckdb_timestamp)>();

  /// !
  /// Append a duckdb_interval value to the appender.
  duckdb_state duckdb_append_interval(
    duckdb_appender appender,
    duckdb_interval value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_interval(
      appender,
      value,
    ));
  }

  late final _duckdb_append_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_interval)>>('duckdb_append_interval');
  late final _duckdb_append_interval = _duckdb_append_intervalPtr
      .asFunction<int Function(duckdb_appender, duckdb_interval)>();

  /// !
  /// Append a varchar value to the appender.
  duckdb_state duckdb_append_varchar(
    duckdb_appender appender,
    ffi.Pointer<ffi.Char> val,
  ) {
    return duckdb_state.fromValue(_duckdb_append_varchar(
      appender,
      val,
    ));
  }

  late final _duckdb_append_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_appender,
              ffi.Pointer<ffi.Char>)>>('duckdb_append_varchar');
  late final _duckdb_append_varchar = _duckdb_append_varcharPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Append a varchar value to the appender.
  duckdb_state duckdb_append_varchar_length(
    duckdb_appender appender,
    ffi.Pointer<ffi.Char> val,
    Dartidx_t length,
  ) {
    return duckdb_state.fromValue(_duckdb_append_varchar_length(
      appender,
      val,
      length,
    ));
  }

  late final _duckdb_append_varchar_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_appender, ffi.Pointer<ffi.Char>,
              idx_t)>>('duckdb_append_varchar_length');
  late final _duckdb_append_varchar_length = _duckdb_append_varchar_lengthPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Append a blob value to the appender.
  duckdb_state duckdb_append_blob(
    duckdb_appender appender,
    ffi.Pointer<ffi.Void> data,
    Dartidx_t length,
  ) {
    return duckdb_state.fromValue(_duckdb_append_blob(
      appender,
      data,
      length,
    ));
  }

  late final _duckdb_append_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_appender, ffi.Pointer<ffi.Void>,
              idx_t)>>('duckdb_append_blob');
  late final _duckdb_append_blob = _duckdb_append_blobPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// Append a NULL value to the appender (of any type).
  duckdb_state duckdb_append_null(
    duckdb_appender appender,
  ) {
    return duckdb_state.fromValue(_duckdb_append_null(
      appender,
    ));
  }

  late final _duckdb_append_nullPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_appender)>>(
          'duckdb_append_null');
  late final _duckdb_append_null =
      _duckdb_append_nullPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Append a duckdb_value to the appender.
  duckdb_state duckdb_append_value(
    duckdb_appender appender,
    duckdb_value value,
  ) {
    return duckdb_state.fromValue(_duckdb_append_value(
      appender,
      value,
    ));
  }

  late final _duckdb_append_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_value)>>('duckdb_append_value');
  late final _duckdb_append_value = _duckdb_append_valuePtr
      .asFunction<int Function(duckdb_appender, duckdb_value)>();

  /// !
  /// Appends a pre-filled data chunk to the specified appender.
  /// Attempts casting, if the data chunk types do not match the active appender types.
  ///
  /// @param appender The appender to append to.
  /// @param chunk The data chunk to append.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_append_data_chunk(
    duckdb_appender appender,
    duckdb_data_chunk chunk,
  ) {
    return duckdb_state.fromValue(_duckdb_append_data_chunk(
      appender,
      chunk,
    ));
  }

  late final _duckdb_append_data_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_appender, duckdb_data_chunk)>>('duckdb_append_data_chunk');
  late final _duckdb_append_data_chunk = _duckdb_append_data_chunkPtr
      .asFunction<int Function(duckdb_appender, duckdb_data_chunk)>();

  /// !
  /// Creates a table description object. Note that `duckdb_table_description_destroy` should always be called on the
  /// resulting table_description, even if the function returns `DuckDBError`.
  ///
  /// @param connection The connection context.
  /// @param schema The schema of the table, or `nullptr` for the default schema.
  /// @param table The table name.
  /// @param out The resulting table description object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_table_description_create(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> schema,
    ffi.Pointer<ffi.Char> table,
    ffi.Pointer<duckdb_table_description> out,
  ) {
    return duckdb_state.fromValue(_duckdb_table_description_create(
      connection,
      schema,
      table,
      out,
    ));
  }

  late final _duckdb_table_description_createPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<duckdb_table_description>)>>(
      'duckdb_table_description_create');
  late final _duckdb_table_description_create =
      _duckdb_table_description_createPtr.asFunction<
          int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_table_description>)>();

  /// !
  /// Creates a table description object. Note that `duckdb_table_description_destroy` must be called on the resulting
  /// table_description, even if the function returns `DuckDBError`.
  ///
  /// @param connection The connection context.
  /// @param catalog The catalog (database) name of the table, or `nullptr` for the default catalog.
  /// @param schema The schema of the table, or `nullptr` for the default schema.
  /// @param table The table name.
  /// @param out The resulting table description object.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_table_description_create_ext(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> catalog,
    ffi.Pointer<ffi.Char> schema,
    ffi.Pointer<ffi.Char> table,
    ffi.Pointer<duckdb_table_description> out,
  ) {
    return duckdb_state.fromValue(_duckdb_table_description_create_ext(
      connection,
      catalog,
      schema,
      table,
      out,
    ));
  }

  late final _duckdb_table_description_create_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(
                  duckdb_connection,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<duckdb_table_description>)>>(
      'duckdb_table_description_create_ext');
  late final _duckdb_table_description_create_ext =
      _duckdb_table_description_create_extPtr.asFunction<
          int Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_table_description>)>();

  /// !
  /// Destroy the TableDescription object.
  ///
  /// @param table_description The table_description to destroy.
  void duckdb_table_description_destroy(
    ffi.Pointer<duckdb_table_description> table_description,
  ) {
    return _duckdb_table_description_destroy(
      table_description,
    );
  }

  late final _duckdb_table_description_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_table_description>)>>(
      'duckdb_table_description_destroy');
  late final _duckdb_table_description_destroy =
      _duckdb_table_description_destroyPtr
          .asFunction<void Function(ffi.Pointer<duckdb_table_description>)>();

  /// !
  /// Returns the error message associated with the given table_description.
  /// If the table_description has no error message, this returns `nullptr` instead.
  /// The error message should not be freed. It will be de-allocated when `duckdb_table_description_destroy` is called.
  ///
  /// @param table_description The table_description to get the error from.
  /// @return The error message, or `nullptr` if there is none.
  ffi.Pointer<ffi.Char> duckdb_table_description_error(
    duckdb_table_description table_description,
  ) {
    return _duckdb_table_description_error(
      table_description,
    );
  }

  late final _duckdb_table_description_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_table_description)>>('duckdb_table_description_error');
  late final _duckdb_table_description_error =
      _duckdb_table_description_errorPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(duckdb_table_description)>();

  /// !
  /// Check if the column at 'index' index of the table has a DEFAULT expression.
  ///
  /// @param table_description The table_description to query.
  /// @param index The index of the column to query.
  /// @param out The out-parameter used to store the result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_column_has_default(
    duckdb_table_description table_description,
    Dartidx_t index,
    ffi.Pointer<ffi.Bool> out,
  ) {
    return duckdb_state.fromValue(_duckdb_column_has_default(
      table_description,
      index,
      out,
    ));
  }

  late final _duckdb_column_has_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_table_description, idx_t,
              ffi.Pointer<ffi.Bool>)>>('duckdb_column_has_default');
  late final _duckdb_column_has_default =
      _duckdb_column_has_defaultPtr.asFunction<
          int Function(duckdb_table_description, int, ffi.Pointer<ffi.Bool>)>();

  /// !
  /// Obtain the column name at 'index'.
  /// The out result must be destroyed with `duckdb_free`.
  ///
  /// @param table_description The table_description to query.
  /// @param index The index of the column to query.
  /// @return The column name.
  ffi.Pointer<ffi.Char> duckdb_table_description_get_column_name(
    duckdb_table_description table_description,
    int index,
  ) {
    return _duckdb_table_description_get_column_name(
      table_description,
      index,
    );
  }

  late final _duckdb_table_description_get_column_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(duckdb_table_description,
              idx_t)>>('duckdb_table_description_get_column_name');
  late final _duckdb_table_description_get_column_name =
      _duckdb_table_description_get_column_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(duckdb_table_description, int)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
  /// If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
  /// `duckdb_query_arrow_error`.
  ///
  /// Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
  /// query fails, otherwise the error stored within the result will not be freed correctly.
  ///
  /// @param connection The connection to perform the query in.
  /// @param query The SQL query to run.
  /// @param out_result The query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_query_arrow(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_arrow> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_query_arrow(
      connection,
      query,
      out_result,
    ));
  }

  late final _duckdb_query_arrowPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_arrow>)>>('duckdb_query_arrow');
  late final _duckdb_query_arrow = _duckdb_query_arrowPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Fetch the internal arrow schema from the arrow result. Remember to call release on the respective
  /// ArrowSchema object.
  ///
  /// @param result The result to fetch the schema from.
  /// @param out_schema The output schema.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_query_arrow_schema(
    duckdb_arrow result,
    ffi.Pointer<duckdb_arrow_schema> out_schema,
  ) {
    return duckdb_state.fromValue(_duckdb_query_arrow_schema(
      result,
      out_schema,
    ));
  }

  late final _duckdb_query_arrow_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_arrow,
              ffi.Pointer<duckdb_arrow_schema>)>>('duckdb_query_arrow_schema');
  late final _duckdb_query_arrow_schema =
      _duckdb_query_arrow_schemaPtr.asFunction<
          int Function(duckdb_arrow, ffi.Pointer<duckdb_arrow_schema>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Fetch the internal arrow schema from the prepared statement. Remember to call release on the respective
  /// ArrowSchema object.
  ///
  /// @param prepared The prepared statement to fetch the schema from.
  /// @param out_schema The output schema.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_prepared_arrow_schema(
    duckdb_prepared_statement prepared,
    ffi.Pointer<duckdb_arrow_schema> out_schema,
  ) {
    return duckdb_state.fromValue(_duckdb_prepared_arrow_schema(
      prepared,
      out_schema,
    ));
  }

  late final _duckdb_prepared_arrow_schemaPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(duckdb_prepared_statement,
                  ffi.Pointer<duckdb_arrow_schema>)>>(
      'duckdb_prepared_arrow_schema');
  late final _duckdb_prepared_arrow_schema =
      _duckdb_prepared_arrow_schemaPtr.asFunction<
          int Function(
              duckdb_prepared_statement, ffi.Pointer<duckdb_arrow_schema>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Convert a data chunk into an arrow struct array. Remember to call release on the respective
  /// ArrowArray object.
  ///
  /// @param result The result object the data chunk have been fetched from.
  /// @param chunk The data chunk to convert.
  /// @param out_array The output array.
  void duckdb_result_arrow_array(
    duckdb_result result,
    duckdb_data_chunk chunk,
    ffi.Pointer<duckdb_arrow_array> out_array,
  ) {
    return _duckdb_result_arrow_array(
      result,
      chunk,
      out_array,
    );
  }

  late final _duckdb_result_arrow_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_result, duckdb_data_chunk,
              ffi.Pointer<duckdb_arrow_array>)>>('duckdb_result_arrow_array');
  late final _duckdb_result_arrow_array =
      _duckdb_result_arrow_arrayPtr.asFunction<
          void Function(duckdb_result, duckdb_data_chunk,
              ffi.Pointer<duckdb_arrow_array>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Fetch an internal arrow struct array from the arrow result. Remember to call release on the respective
  /// ArrowArray object.
  ///
  /// This function can be called multiple time to get next chunks, which will free the previous out_array.
  /// So consume the out_array before calling this function again.
  ///
  /// @param result The result to fetch the array from.
  /// @param out_array The output array.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_query_arrow_array(
    duckdb_arrow result,
    ffi.Pointer<duckdb_arrow_array> out_array,
  ) {
    return duckdb_state.fromValue(_duckdb_query_arrow_array(
      result,
      out_array,
    ));
  }

  late final _duckdb_query_arrow_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_arrow,
              ffi.Pointer<duckdb_arrow_array>)>>('duckdb_query_arrow_array');
  late final _duckdb_query_arrow_array =
      _duckdb_query_arrow_arrayPtr.asFunction<
          int Function(duckdb_arrow, ffi.Pointer<duckdb_arrow_array>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the number of columns present in the arrow result object.
  ///
  /// @param result The result object.
  /// @return The number of columns present in the result object.
  int duckdb_arrow_column_count(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_column_count(
      result,
    );
  }

  late final _duckdb_arrow_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_column_count');
  late final _duckdb_arrow_column_count =
      _duckdb_arrow_column_countPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the number of rows present in the arrow result object.
  ///
  /// @param result The result object.
  /// @return The number of rows present in the result object.
  int duckdb_arrow_row_count(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_row_count(
      result,
    );
  }

  late final _duckdb_arrow_row_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_row_count');
  late final _duckdb_arrow_row_count =
      _duckdb_arrow_row_countPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
  /// INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
  ///
  /// @param result The result object.
  /// @return The number of rows changed.
  int duckdb_arrow_rows_changed(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_rows_changed(
      result,
    );
  }

  late final _duckdb_arrow_rows_changedPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_rows_changed');
  late final _duckdb_arrow_rows_changed =
      _duckdb_arrow_rows_changedPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
  /// `DuckDBError`.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
  ///
  /// @param result The result object to fetch the error from.
  /// @return The error of the result.
  ffi.Pointer<ffi.Char> duckdb_query_arrow_error(
    duckdb_arrow result,
  ) {
    return _duckdb_query_arrow_error(
      result,
    );
  }

  late final _duckdb_query_arrow_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_arrow)>>(
          'duckdb_query_arrow_error');
  late final _duckdb_query_arrow_error = _duckdb_query_arrow_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_arrow)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Closes the result and de-allocates all memory allocated for the arrow result.
  ///
  /// @param result The result to destroy.
  void duckdb_destroy_arrow(
    ffi.Pointer<duckdb_arrow> result,
  ) {
    return _duckdb_destroy_arrow(
      result,
    );
  }

  late final _duckdb_destroy_arrowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_arrow>)>>(
          'duckdb_destroy_arrow');
  late final _duckdb_destroy_arrow = _duckdb_destroy_arrowPtr
      .asFunction<void Function(ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Releases the arrow array stream and de-allocates its memory.
  ///
  /// @param stream_p The arrow array stream to destroy.
  void duckdb_destroy_arrow_stream(
    ffi.Pointer<duckdb_arrow_stream> stream_p,
  ) {
    return _duckdb_destroy_arrow_stream(
      stream_p,
    );
  }

  late final _duckdb_destroy_arrow_streamPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_arrow_stream>)>>(
      'duckdb_destroy_arrow_stream');
  late final _duckdb_destroy_arrow_stream = _duckdb_destroy_arrow_streamPtr
      .asFunction<void Function(ffi.Pointer<duckdb_arrow_stream>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Executes the prepared statement with the given bound parameters, and returns an arrow query result.
  /// Note that after running `duckdb_execute_prepared_arrow`, `duckdb_destroy_arrow` must be called on the result object.
  ///
  /// @param prepared_statement The prepared statement to execute.
  /// @param out_result The query result.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_execute_prepared_arrow(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_arrow> out_result,
  ) {
    return duckdb_state.fromValue(_duckdb_execute_prepared_arrow(
      prepared_statement,
      out_result,
    ));
  }

  late final _duckdb_execute_prepared_arrowPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_arrow>)>>('duckdb_execute_prepared_arrow');
  late final _duckdb_execute_prepared_arrow =
      _duckdb_execute_prepared_arrowPtr.asFunction<
          int Function(duckdb_prepared_statement, ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Scans the Arrow stream and creates a view with the given name.
  ///
  /// @param connection The connection on which to execute the scan.
  /// @param table_name Name of the temporary view to create.
  /// @param arrow Arrow stream wrapper.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_arrow_scan(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> table_name,
    duckdb_arrow_stream arrow,
  ) {
    return duckdb_state.fromValue(_duckdb_arrow_scan(
      connection,
      table_name,
      arrow,
    ));
  }

  late final _duckdb_arrow_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              duckdb_arrow_stream)>>('duckdb_arrow_scan');
  late final _duckdb_arrow_scan = _duckdb_arrow_scanPtr.asFunction<
      int Function(
          duckdb_connection, ffi.Pointer<ffi.Char>, duckdb_arrow_stream)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Scans the Arrow array and creates a view with the given name.
  /// Note that after running `duckdb_arrow_array_scan`, `duckdb_destroy_arrow_stream` must be called on the out stream.
  ///
  /// @param connection The connection on which to execute the scan.
  /// @param table_name Name of the temporary view to create.
  /// @param arrow_schema Arrow schema wrapper.
  /// @param arrow_array Arrow array wrapper.
  /// @param out_stream Output array stream that wraps around the passed schema, for releasing/deleting once done.
  /// @return `DuckDBSuccess` on success or `DuckDBError` on failure.
  duckdb_state duckdb_arrow_array_scan(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> table_name,
    duckdb_arrow_schema arrow_schema,
    duckdb_arrow_array arrow_array,
    ffi.Pointer<duckdb_arrow_stream> out_stream,
  ) {
    return duckdb_state.fromValue(_duckdb_arrow_array_scan(
      connection,
      table_name,
      arrow_schema,
      arrow_array,
      out_stream,
    ));
  }

  late final _duckdb_arrow_array_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              duckdb_arrow_schema,
              duckdb_arrow_array,
              ffi.Pointer<duckdb_arrow_stream>)>>('duckdb_arrow_array_scan');
  late final _duckdb_arrow_array_scan = _duckdb_arrow_array_scanPtr.asFunction<
      int Function(
          duckdb_connection,
          ffi.Pointer<ffi.Char>,
          duckdb_arrow_schema,
          duckdb_arrow_array,
          ffi.Pointer<duckdb_arrow_stream>)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// Will return after `max_tasks` have been executed, or if there are no more tasks present.
  ///
  /// @param database The database object to execute tasks for
  /// @param max_tasks The maximum amount of tasks to execute
  void duckdb_execute_tasks(
    duckdb_database database,
    int max_tasks,
  ) {
    return _duckdb_execute_tasks(
      database,
      max_tasks,
    );
  }

  late final _duckdb_execute_tasksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_database, idx_t)>>(
          'duckdb_execute_tasks');
  late final _duckdb_execute_tasks = _duckdb_execute_tasksPtr
      .asFunction<void Function(duckdb_database, int)>();

  /// !
  /// Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
  /// `duckdb_finish_execution` is called on the state.
  ///
  /// `duckdb_destroy_state` must be called on the result.
  ///
  /// @param database The database object to create the task state for
  /// @return The task state that can be used with duckdb_execute_tasks_state.
  duckdb_task_state duckdb_create_task_state(
    duckdb_database database,
  ) {
    return _duckdb_create_task_state(
      database,
    );
  }

  late final _duckdb_create_task_statePtr =
      _lookup<ffi.NativeFunction<duckdb_task_state Function(duckdb_database)>>(
          'duckdb_create_task_state');
  late final _duckdb_create_task_state = _duckdb_create_task_statePtr
      .asFunction<duckdb_task_state Function(duckdb_database)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
  /// Multiple threads can share the same duckdb_task_state.
  ///
  /// @param state The task state of the executor
  void duckdb_execute_tasks_state(
    duckdb_task_state state,
  ) {
    return _duckdb_execute_tasks_state(
      state,
    );
  }

  late final _duckdb_execute_tasks_statePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_execute_tasks_state');
  late final _duckdb_execute_tasks_state = _duckdb_execute_tasks_statePtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
  /// max_tasks tasks have been executed or there are no more tasks to be executed.
  ///
  /// Multiple threads can share the same duckdb_task_state.
  ///
  /// @param state The task state of the executor
  /// @param max_tasks The maximum amount of tasks to execute
  /// @return The amount of tasks that have actually been executed
  int duckdb_execute_n_tasks_state(
    duckdb_task_state state,
    int max_tasks,
  ) {
    return _duckdb_execute_n_tasks_state(
      state,
      max_tasks,
    );
  }

  late final _duckdb_execute_n_tasks_statePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_task_state, idx_t)>>(
          'duckdb_execute_n_tasks_state');
  late final _duckdb_execute_n_tasks_state = _duckdb_execute_n_tasks_statePtr
      .asFunction<int Function(duckdb_task_state, int)>();

  /// !
  /// Finish execution on a specific task.
  ///
  /// @param state The task state to finish execution
  void duckdb_finish_execution(
    duckdb_task_state state,
  ) {
    return _duckdb_finish_execution(
      state,
    );
  }

  late final _duckdb_finish_executionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_finish_execution');
  late final _duckdb_finish_execution = _duckdb_finish_executionPtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Check if the provided duckdb_task_state has finished execution
  ///
  /// @param state The task state to inspect
  /// @return Whether or not duckdb_finish_execution has been called on the task state
  bool duckdb_task_state_is_finished(
    duckdb_task_state state,
  ) {
    return _duckdb_task_state_is_finished(
      state,
    );
  }

  late final _duckdb_task_state_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_task_state)>>(
          'duckdb_task_state_is_finished');
  late final _duckdb_task_state_is_finished = _duckdb_task_state_is_finishedPtr
      .asFunction<bool Function(duckdb_task_state)>();

  /// !
  /// Destroys the task state returned from duckdb_create_task_state.
  ///
  /// Note that this should not be called while there is an active duckdb_execute_tasks_state running
  /// on the task state.
  ///
  /// @param state The task state to clean up
  void duckdb_destroy_task_state(
    duckdb_task_state state,
  ) {
    return _duckdb_destroy_task_state(
      state,
    );
  }

  late final _duckdb_destroy_task_statePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_destroy_task_state');
  late final _duckdb_destroy_task_state = _duckdb_destroy_task_statePtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Returns true if the execution of the current query is finished.
  ///
  /// @param con The connection on which to check
  bool duckdb_execution_is_finished(
    duckdb_connection con,
  ) {
    return _duckdb_execution_is_finished(
      con,
    );
  }

  late final _duckdb_execution_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_connection)>>(
          'duckdb_execution_is_finished');
  late final _duckdb_execution_is_finished = _duckdb_execution_is_finishedPtr
      .asFunction<bool Function(duckdb_connection)>();

  /// !
  /// DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
  ///
  /// Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
  /// exhausted.
  ///
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'
  ///
  /// If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
  /// mixed with the legacy result functions or the materialized result functions).
  ///
  /// It is not known beforehand how many chunks will be returned by this result.
  ///
  /// @param result The result object to fetch the data chunk from.
  /// @return The resulting data chunk. Returns `NULL` if the result has an error.
  duckdb_data_chunk duckdb_stream_fetch_chunk(
    duckdb_result result,
  ) {
    return _duckdb_stream_fetch_chunk(
      result,
    );
  }

  late final _duckdb_stream_fetch_chunkPtr =
      _lookup<ffi.NativeFunction<duckdb_data_chunk Function(duckdb_result)>>(
          'duckdb_stream_fetch_chunk');
  late final _duckdb_stream_fetch_chunk = _duckdb_stream_fetch_chunkPtr
      .asFunction<duckdb_data_chunk Function(duckdb_result)>();

  /// !
  /// Fetches a data chunk from a duckdb_result. This function should be called repeatedly until the result is exhausted.
  ///
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// It is not known beforehand how many chunks will be returned by this result.
  ///
  /// @param result The result object to fetch the data chunk from.
  /// @return The resulting data chunk. Returns `NULL` if the result has an error.
  duckdb_data_chunk duckdb_fetch_chunk(
    duckdb_result result,
  ) {
    return _duckdb_fetch_chunk(
      result,
    );
  }

  late final _duckdb_fetch_chunkPtr =
      _lookup<ffi.NativeFunction<duckdb_data_chunk Function(duckdb_result)>>(
          'duckdb_fetch_chunk');
  late final _duckdb_fetch_chunk = _duckdb_fetch_chunkPtr
      .asFunction<duckdb_data_chunk Function(duckdb_result)>();

  /// !
  /// Creates a new cast function object.
  ///
  /// @return The cast function object.
  duckdb_cast_function duckdb_create_cast_function() {
    return _duckdb_create_cast_function();
  }

  late final _duckdb_create_cast_functionPtr =
      _lookup<ffi.NativeFunction<duckdb_cast_function Function()>>(
          'duckdb_create_cast_function');
  late final _duckdb_create_cast_function = _duckdb_create_cast_functionPtr
      .asFunction<duckdb_cast_function Function()>();

  /// !
  /// Sets the source type of the cast function.
  ///
  /// @param cast_function The cast function object.
  /// @param source_type The source type to set.
  void duckdb_cast_function_set_source_type(
    duckdb_cast_function cast_function,
    duckdb_logical_type source_type,
  ) {
    return _duckdb_cast_function_set_source_type(
      cast_function,
      source_type,
    );
  }

  late final _duckdb_cast_function_set_source_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_cast_function,
              duckdb_logical_type)>>('duckdb_cast_function_set_source_type');
  late final _duckdb_cast_function_set_source_type =
      _duckdb_cast_function_set_source_typePtr.asFunction<
          void Function(duckdb_cast_function, duckdb_logical_type)>();

  /// !
  /// Sets the target type of the cast function.
  ///
  /// @param cast_function The cast function object.
  /// @param target_type The target type to set.
  void duckdb_cast_function_set_target_type(
    duckdb_cast_function cast_function,
    duckdb_logical_type target_type,
  ) {
    return _duckdb_cast_function_set_target_type(
      cast_function,
      target_type,
    );
  }

  late final _duckdb_cast_function_set_target_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_cast_function,
              duckdb_logical_type)>>('duckdb_cast_function_set_target_type');
  late final _duckdb_cast_function_set_target_type =
      _duckdb_cast_function_set_target_typePtr.asFunction<
          void Function(duckdb_cast_function, duckdb_logical_type)>();

  /// !
  /// Sets the "cost" of implicitly casting the source type to the target type using this function.
  ///
  /// @param cast_function The cast function object.
  /// @param cost The cost to set.
  void duckdb_cast_function_set_implicit_cast_cost(
    duckdb_cast_function cast_function,
    int cost,
  ) {
    return _duckdb_cast_function_set_implicit_cast_cost(
      cast_function,
      cost,
    );
  }

  late final _duckdb_cast_function_set_implicit_cast_costPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(duckdb_cast_function, ffi.Int64)>>(
      'duckdb_cast_function_set_implicit_cast_cost');
  late final _duckdb_cast_function_set_implicit_cast_cost =
      _duckdb_cast_function_set_implicit_cast_costPtr
          .asFunction<void Function(duckdb_cast_function, int)>();

  /// !
  /// Sets the actual cast function to use.
  ///
  /// @param cast_function The cast function object.
  /// @param function The function to set.
  void duckdb_cast_function_set_function(
    duckdb_cast_function cast_function,
    duckdb_cast_function_t function,
  ) {
    return _duckdb_cast_function_set_function(
      cast_function,
      function,
    );
  }

  late final _duckdb_cast_function_set_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_cast_function,
              duckdb_cast_function_t)>>('duckdb_cast_function_set_function');
  late final _duckdb_cast_function_set_function =
      _duckdb_cast_function_set_functionPtr.asFunction<
          void Function(duckdb_cast_function, duckdb_cast_function_t)>();

  /// !
  /// Assigns extra information to the cast function that can be fetched during execution, etc.
  ///
  /// @param extra_info The extra information
  /// @param destroy The callback that will be called to destroy the extra information (if any)
  void duckdb_cast_function_set_extra_info(
    duckdb_cast_function cast_function,
    ffi.Pointer<ffi.Void> extra_info,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_cast_function_set_extra_info(
      cast_function,
      extra_info,
      destroy,
    );
  }

  late final _duckdb_cast_function_set_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_cast_function, ffi.Pointer<ffi.Void>,
                  duckdb_delete_callback_t)>>(
      'duckdb_cast_function_set_extra_info');
  late final _duckdb_cast_function_set_extra_info =
      _duckdb_cast_function_set_extra_infoPtr.asFunction<
          void Function(duckdb_cast_function, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_cast_function_set_extra_info`.
  ///
  /// @param info The info object.
  /// @return The extra info.
  ffi.Pointer<ffi.Void> duckdb_cast_function_get_extra_info(
    duckdb_function_info info,
  ) {
    return _duckdb_cast_function_get_extra_info(
      info,
    );
  }

  late final _duckdb_cast_function_get_extra_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_cast_function_get_extra_info');
  late final _duckdb_cast_function_get_extra_info =
      _duckdb_cast_function_get_extra_infoPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Get the cast execution mode from the given function info.
  ///
  /// @param info The info object.
  /// @return The cast mode.
  duckdb_cast_mode duckdb_cast_function_get_cast_mode(
    duckdb_function_info info,
  ) {
    return duckdb_cast_mode.fromValue(_duckdb_cast_function_get_cast_mode(
      info,
    ));
  }

  late final _duckdb_cast_function_get_cast_modePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(duckdb_function_info)>>(
      'duckdb_cast_function_get_cast_mode');
  late final _duckdb_cast_function_get_cast_mode =
      _duckdb_cast_function_get_cast_modePtr
          .asFunction<int Function(duckdb_function_info)>();

  /// !
  /// Report that an error has occurred while executing the cast function.
  ///
  /// @param info The info object.
  /// @param error The error message.
  void duckdb_cast_function_set_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_cast_function_set_error(
      info,
      error,
    );
  }

  late final _duckdb_cast_function_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_cast_function_set_error');
  late final _duckdb_cast_function_set_error =
      _duckdb_cast_function_set_errorPtr.asFunction<
          void Function(duckdb_function_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Report that an error has occurred while executing the cast function, setting the corresponding output row to NULL.
  ///
  /// @param info The info object.
  /// @param error The error message.
  /// @param row The index of the row within the output vector to set to NULL.
  /// @param output The output vector.
  void duckdb_cast_function_set_row_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
    int row,
    duckdb_vector output,
  ) {
    return _duckdb_cast_function_set_row_error(
      info,
      error,
      row,
      output,
    );
  }

  late final _duckdb_cast_function_set_row_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info, ffi.Pointer<ffi.Char>, idx_t,
              duckdb_vector)>>('duckdb_cast_function_set_row_error');
  late final _duckdb_cast_function_set_row_error =
      _duckdb_cast_function_set_row_errorPtr.asFunction<
          void Function(duckdb_function_info, ffi.Pointer<ffi.Char>, int,
              duckdb_vector)>();

  /// !
  /// Registers a cast function within the given connection.
  ///
  /// @param con The connection to use.
  /// @param cast_function The cast function to register.
  /// @return Whether or not the registration was successful.
  duckdb_state duckdb_register_cast_function(
    duckdb_connection con,
    duckdb_cast_function cast_function,
  ) {
    return duckdb_state.fromValue(_duckdb_register_cast_function(
      con,
      cast_function,
    ));
  }

  late final _duckdb_register_cast_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(duckdb_connection,
              duckdb_cast_function)>>('duckdb_register_cast_function');
  late final _duckdb_register_cast_function = _duckdb_register_cast_functionPtr
      .asFunction<int Function(duckdb_connection, duckdb_cast_function)>();

  /// !
  /// Destroys the cast function object.
  ///
  /// @param cast_function The cast function object.
  void duckdb_destroy_cast_function(
    ffi.Pointer<duckdb_cast_function> cast_function,
  ) {
    return _duckdb_destroy_cast_function(
      cast_function,
    );
  }

  late final _duckdb_destroy_cast_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_cast_function>)>>(
      'duckdb_destroy_cast_function');
  late final _duckdb_destroy_cast_function = _duckdb_destroy_cast_functionPtr
      .asFunction<void Function(ffi.Pointer<duckdb_cast_function>)>();
}

/// ! An enum over DuckDB's internal types.
enum DUCKDB_TYPE {
  DUCKDB_TYPE_INVALID(0),
  DUCKDB_TYPE_BOOLEAN(1),
  DUCKDB_TYPE_TINYINT(2),
  DUCKDB_TYPE_SMALLINT(3),
  DUCKDB_TYPE_INTEGER(4),
  DUCKDB_TYPE_BIGINT(5),
  DUCKDB_TYPE_UTINYINT(6),
  DUCKDB_TYPE_USMALLINT(7),
  DUCKDB_TYPE_UINTEGER(8),
  DUCKDB_TYPE_UBIGINT(9),
  DUCKDB_TYPE_FLOAT(10),
  DUCKDB_TYPE_DOUBLE(11),
  DUCKDB_TYPE_TIMESTAMP(12),
  DUCKDB_TYPE_DATE(13),
  DUCKDB_TYPE_TIME(14),
  DUCKDB_TYPE_INTERVAL(15),
  DUCKDB_TYPE_HUGEINT(16),
  DUCKDB_TYPE_UHUGEINT(32),
  DUCKDB_TYPE_VARCHAR(17),
  DUCKDB_TYPE_BLOB(18),
  DUCKDB_TYPE_DECIMAL(19),
  DUCKDB_TYPE_TIMESTAMP_S(20),
  DUCKDB_TYPE_TIMESTAMP_MS(21),
  DUCKDB_TYPE_TIMESTAMP_NS(22),
  DUCKDB_TYPE_ENUM(23),
  DUCKDB_TYPE_LIST(24),
  DUCKDB_TYPE_STRUCT(25),
  DUCKDB_TYPE_MAP(26),
  DUCKDB_TYPE_ARRAY(33),
  DUCKDB_TYPE_UUID(27),
  DUCKDB_TYPE_UNION(28),
  DUCKDB_TYPE_BIT(29),
  DUCKDB_TYPE_TIME_TZ(30),
  DUCKDB_TYPE_TIMESTAMP_TZ(31),
  DUCKDB_TYPE_ANY(34),
  DUCKDB_TYPE_VARINT(35),
  DUCKDB_TYPE_SQLNULL(36);

  final int value;
  const DUCKDB_TYPE(this.value);

  static DUCKDB_TYPE fromValue(int value) => switch (value) {
        0 => DUCKDB_TYPE_INVALID,
        1 => DUCKDB_TYPE_BOOLEAN,
        2 => DUCKDB_TYPE_TINYINT,
        3 => DUCKDB_TYPE_SMALLINT,
        4 => DUCKDB_TYPE_INTEGER,
        5 => DUCKDB_TYPE_BIGINT,
        6 => DUCKDB_TYPE_UTINYINT,
        7 => DUCKDB_TYPE_USMALLINT,
        8 => DUCKDB_TYPE_UINTEGER,
        9 => DUCKDB_TYPE_UBIGINT,
        10 => DUCKDB_TYPE_FLOAT,
        11 => DUCKDB_TYPE_DOUBLE,
        12 => DUCKDB_TYPE_TIMESTAMP,
        13 => DUCKDB_TYPE_DATE,
        14 => DUCKDB_TYPE_TIME,
        15 => DUCKDB_TYPE_INTERVAL,
        16 => DUCKDB_TYPE_HUGEINT,
        32 => DUCKDB_TYPE_UHUGEINT,
        17 => DUCKDB_TYPE_VARCHAR,
        18 => DUCKDB_TYPE_BLOB,
        19 => DUCKDB_TYPE_DECIMAL,
        20 => DUCKDB_TYPE_TIMESTAMP_S,
        21 => DUCKDB_TYPE_TIMESTAMP_MS,
        22 => DUCKDB_TYPE_TIMESTAMP_NS,
        23 => DUCKDB_TYPE_ENUM,
        24 => DUCKDB_TYPE_LIST,
        25 => DUCKDB_TYPE_STRUCT,
        26 => DUCKDB_TYPE_MAP,
        33 => DUCKDB_TYPE_ARRAY,
        27 => DUCKDB_TYPE_UUID,
        28 => DUCKDB_TYPE_UNION,
        29 => DUCKDB_TYPE_BIT,
        30 => DUCKDB_TYPE_TIME_TZ,
        31 => DUCKDB_TYPE_TIMESTAMP_TZ,
        34 => DUCKDB_TYPE_ANY,
        35 => DUCKDB_TYPE_VARINT,
        36 => DUCKDB_TYPE_SQLNULL,
        _ => throw ArgumentError("Unknown value for DUCKDB_TYPE: $value"),
      };
}

/// ! An enum over the returned state of different functions.
enum duckdb_state {
  DuckDBSuccess(0),
  DuckDBError(1);

  final int value;
  const duckdb_state(this.value);

  static duckdb_state fromValue(int value) => switch (value) {
        0 => DuckDBSuccess,
        1 => DuckDBError,
        _ => throw ArgumentError("Unknown value for duckdb_state: $value"),
      };
}

/// ! An enum over the pending state of a pending query result.
enum duckdb_pending_state {
  DUCKDB_PENDING_RESULT_READY(0),
  DUCKDB_PENDING_RESULT_NOT_READY(1),
  DUCKDB_PENDING_ERROR(2),
  DUCKDB_PENDING_NO_TASKS_AVAILABLE(3);

  final int value;
  const duckdb_pending_state(this.value);

  static duckdb_pending_state fromValue(int value) => switch (value) {
        0 => DUCKDB_PENDING_RESULT_READY,
        1 => DUCKDB_PENDING_RESULT_NOT_READY,
        2 => DUCKDB_PENDING_ERROR,
        3 => DUCKDB_PENDING_NO_TASKS_AVAILABLE,
        _ =>
          throw ArgumentError("Unknown value for duckdb_pending_state: $value"),
      };
}

/// ! An enum over DuckDB's different result types.
enum duckdb_result_type {
  DUCKDB_RESULT_TYPE_INVALID(0),
  DUCKDB_RESULT_TYPE_CHANGED_ROWS(1),
  DUCKDB_RESULT_TYPE_NOTHING(2),
  DUCKDB_RESULT_TYPE_QUERY_RESULT(3);

  final int value;
  const duckdb_result_type(this.value);

  static duckdb_result_type fromValue(int value) => switch (value) {
        0 => DUCKDB_RESULT_TYPE_INVALID,
        1 => DUCKDB_RESULT_TYPE_CHANGED_ROWS,
        2 => DUCKDB_RESULT_TYPE_NOTHING,
        3 => DUCKDB_RESULT_TYPE_QUERY_RESULT,
        _ =>
          throw ArgumentError("Unknown value for duckdb_result_type: $value"),
      };
}

/// ! An enum over DuckDB's different statement types.
enum duckdb_statement_type {
  DUCKDB_STATEMENT_TYPE_INVALID(0),
  DUCKDB_STATEMENT_TYPE_SELECT(1),
  DUCKDB_STATEMENT_TYPE_INSERT(2),
  DUCKDB_STATEMENT_TYPE_UPDATE(3),
  DUCKDB_STATEMENT_TYPE_EXPLAIN(4),
  DUCKDB_STATEMENT_TYPE_DELETE(5),
  DUCKDB_STATEMENT_TYPE_PREPARE(6),
  DUCKDB_STATEMENT_TYPE_CREATE(7),
  DUCKDB_STATEMENT_TYPE_EXECUTE(8),
  DUCKDB_STATEMENT_TYPE_ALTER(9),
  DUCKDB_STATEMENT_TYPE_TRANSACTION(10),
  DUCKDB_STATEMENT_TYPE_COPY(11),
  DUCKDB_STATEMENT_TYPE_ANALYZE(12),
  DUCKDB_STATEMENT_TYPE_VARIABLE_SET(13),
  DUCKDB_STATEMENT_TYPE_CREATE_FUNC(14),
  DUCKDB_STATEMENT_TYPE_DROP(15),
  DUCKDB_STATEMENT_TYPE_EXPORT(16),
  DUCKDB_STATEMENT_TYPE_PRAGMA(17),
  DUCKDB_STATEMENT_TYPE_VACUUM(18),
  DUCKDB_STATEMENT_TYPE_CALL(19),
  DUCKDB_STATEMENT_TYPE_SET(20),
  DUCKDB_STATEMENT_TYPE_LOAD(21),
  DUCKDB_STATEMENT_TYPE_RELATION(22),
  DUCKDB_STATEMENT_TYPE_EXTENSION(23),
  DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN(24),
  DUCKDB_STATEMENT_TYPE_ATTACH(25),
  DUCKDB_STATEMENT_TYPE_DETACH(26),
  DUCKDB_STATEMENT_TYPE_MULTI(27);

  final int value;
  const duckdb_statement_type(this.value);

  static duckdb_statement_type fromValue(int value) => switch (value) {
        0 => DUCKDB_STATEMENT_TYPE_INVALID,
        1 => DUCKDB_STATEMENT_TYPE_SELECT,
        2 => DUCKDB_STATEMENT_TYPE_INSERT,
        3 => DUCKDB_STATEMENT_TYPE_UPDATE,
        4 => DUCKDB_STATEMENT_TYPE_EXPLAIN,
        5 => DUCKDB_STATEMENT_TYPE_DELETE,
        6 => DUCKDB_STATEMENT_TYPE_PREPARE,
        7 => DUCKDB_STATEMENT_TYPE_CREATE,
        8 => DUCKDB_STATEMENT_TYPE_EXECUTE,
        9 => DUCKDB_STATEMENT_TYPE_ALTER,
        10 => DUCKDB_STATEMENT_TYPE_TRANSACTION,
        11 => DUCKDB_STATEMENT_TYPE_COPY,
        12 => DUCKDB_STATEMENT_TYPE_ANALYZE,
        13 => DUCKDB_STATEMENT_TYPE_VARIABLE_SET,
        14 => DUCKDB_STATEMENT_TYPE_CREATE_FUNC,
        15 => DUCKDB_STATEMENT_TYPE_DROP,
        16 => DUCKDB_STATEMENT_TYPE_EXPORT,
        17 => DUCKDB_STATEMENT_TYPE_PRAGMA,
        18 => DUCKDB_STATEMENT_TYPE_VACUUM,
        19 => DUCKDB_STATEMENT_TYPE_CALL,
        20 => DUCKDB_STATEMENT_TYPE_SET,
        21 => DUCKDB_STATEMENT_TYPE_LOAD,
        22 => DUCKDB_STATEMENT_TYPE_RELATION,
        23 => DUCKDB_STATEMENT_TYPE_EXTENSION,
        24 => DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN,
        25 => DUCKDB_STATEMENT_TYPE_ATTACH,
        26 => DUCKDB_STATEMENT_TYPE_DETACH,
        27 => DUCKDB_STATEMENT_TYPE_MULTI,
        _ => throw ArgumentError(
            "Unknown value for duckdb_statement_type: $value"),
      };
}

/// ! An enum over DuckDB's different result types.
enum duckdb_error_type {
  DUCKDB_ERROR_INVALID(0),
  DUCKDB_ERROR_OUT_OF_RANGE(1),
  DUCKDB_ERROR_CONVERSION(2),
  DUCKDB_ERROR_UNKNOWN_TYPE(3),
  DUCKDB_ERROR_DECIMAL(4),
  DUCKDB_ERROR_MISMATCH_TYPE(5),
  DUCKDB_ERROR_DIVIDE_BY_ZERO(6),
  DUCKDB_ERROR_OBJECT_SIZE(7),
  DUCKDB_ERROR_INVALID_TYPE(8),
  DUCKDB_ERROR_SERIALIZATION(9),
  DUCKDB_ERROR_TRANSACTION(10),
  DUCKDB_ERROR_NOT_IMPLEMENTED(11),
  DUCKDB_ERROR_EXPRESSION(12),
  DUCKDB_ERROR_CATALOG(13),
  DUCKDB_ERROR_PARSER(14),
  DUCKDB_ERROR_PLANNER(15),
  DUCKDB_ERROR_SCHEDULER(16),
  DUCKDB_ERROR_EXECUTOR(17),
  DUCKDB_ERROR_CONSTRAINT(18),
  DUCKDB_ERROR_INDEX(19),
  DUCKDB_ERROR_STAT(20),
  DUCKDB_ERROR_CONNECTION(21),
  DUCKDB_ERROR_SYNTAX(22),
  DUCKDB_ERROR_SETTINGS(23),
  DUCKDB_ERROR_BINDER(24),
  DUCKDB_ERROR_NETWORK(25),
  DUCKDB_ERROR_OPTIMIZER(26),
  DUCKDB_ERROR_NULL_POINTER(27),
  DUCKDB_ERROR_IO(28),
  DUCKDB_ERROR_INTERRUPT(29),
  DUCKDB_ERROR_FATAL(30),
  DUCKDB_ERROR_INTERNAL(31),
  DUCKDB_ERROR_INVALID_INPUT(32),
  DUCKDB_ERROR_OUT_OF_MEMORY(33),
  DUCKDB_ERROR_PERMISSION(34),
  DUCKDB_ERROR_PARAMETER_NOT_RESOLVED(35),
  DUCKDB_ERROR_PARAMETER_NOT_ALLOWED(36),
  DUCKDB_ERROR_DEPENDENCY(37),
  DUCKDB_ERROR_HTTP(38),
  DUCKDB_ERROR_MISSING_EXTENSION(39),
  DUCKDB_ERROR_AUTOLOAD(40),
  DUCKDB_ERROR_SEQUENCE(41),
  DUCKDB_INVALID_CONFIGURATION(42);

  final int value;
  const duckdb_error_type(this.value);

  static duckdb_error_type fromValue(int value) => switch (value) {
        0 => DUCKDB_ERROR_INVALID,
        1 => DUCKDB_ERROR_OUT_OF_RANGE,
        2 => DUCKDB_ERROR_CONVERSION,
        3 => DUCKDB_ERROR_UNKNOWN_TYPE,
        4 => DUCKDB_ERROR_DECIMAL,
        5 => DUCKDB_ERROR_MISMATCH_TYPE,
        6 => DUCKDB_ERROR_DIVIDE_BY_ZERO,
        7 => DUCKDB_ERROR_OBJECT_SIZE,
        8 => DUCKDB_ERROR_INVALID_TYPE,
        9 => DUCKDB_ERROR_SERIALIZATION,
        10 => DUCKDB_ERROR_TRANSACTION,
        11 => DUCKDB_ERROR_NOT_IMPLEMENTED,
        12 => DUCKDB_ERROR_EXPRESSION,
        13 => DUCKDB_ERROR_CATALOG,
        14 => DUCKDB_ERROR_PARSER,
        15 => DUCKDB_ERROR_PLANNER,
        16 => DUCKDB_ERROR_SCHEDULER,
        17 => DUCKDB_ERROR_EXECUTOR,
        18 => DUCKDB_ERROR_CONSTRAINT,
        19 => DUCKDB_ERROR_INDEX,
        20 => DUCKDB_ERROR_STAT,
        21 => DUCKDB_ERROR_CONNECTION,
        22 => DUCKDB_ERROR_SYNTAX,
        23 => DUCKDB_ERROR_SETTINGS,
        24 => DUCKDB_ERROR_BINDER,
        25 => DUCKDB_ERROR_NETWORK,
        26 => DUCKDB_ERROR_OPTIMIZER,
        27 => DUCKDB_ERROR_NULL_POINTER,
        28 => DUCKDB_ERROR_IO,
        29 => DUCKDB_ERROR_INTERRUPT,
        30 => DUCKDB_ERROR_FATAL,
        31 => DUCKDB_ERROR_INTERNAL,
        32 => DUCKDB_ERROR_INVALID_INPUT,
        33 => DUCKDB_ERROR_OUT_OF_MEMORY,
        34 => DUCKDB_ERROR_PERMISSION,
        35 => DUCKDB_ERROR_PARAMETER_NOT_RESOLVED,
        36 => DUCKDB_ERROR_PARAMETER_NOT_ALLOWED,
        37 => DUCKDB_ERROR_DEPENDENCY,
        38 => DUCKDB_ERROR_HTTP,
        39 => DUCKDB_ERROR_MISSING_EXTENSION,
        40 => DUCKDB_ERROR_AUTOLOAD,
        41 => DUCKDB_ERROR_SEQUENCE,
        42 => DUCKDB_INVALID_CONFIGURATION,
        _ => throw ArgumentError("Unknown value for duckdb_error_type: $value"),
      };
}

/// ! An enum over DuckDB's different cast modes.
enum duckdb_cast_mode {
  DUCKDB_CAST_NORMAL(0),
  DUCKDB_CAST_TRY(1);

  final int value;
  const duckdb_cast_mode(this.value);

  static duckdb_cast_mode fromValue(int value) => switch (value) {
        0 => DUCKDB_CAST_NORMAL,
        1 => DUCKDB_CAST_TRY,
        _ => throw ArgumentError("Unknown value for duckdb_cast_mode: $value"),
      };
}

/// ! Days are stored as days since 1970-01-01
/// ! Use the duckdb_from_date/duckdb_to_date function to extract individual information
final class duckdb_date extends ffi.Struct {
  @ffi.Int32()
  external int days;
}

final class duckdb_date_struct extends ffi.Struct {
  @ffi.Int32()
  external int year;

  @ffi.Int8()
  external int month;

  @ffi.Int8()
  external int day;
}

/// ! Time is stored as microseconds since 00:00:00
/// ! Use the duckdb_from_time/duckdb_to_time function to extract individual information
final class duckdb_time extends ffi.Struct {
  @ffi.Int64()
  external int micros;
}

final class duckdb_time_struct extends ffi.Struct {
  @ffi.Int8()
  external int hour;

  @ffi.Int8()
  external int min;

  @ffi.Int8()
  external int sec;

  @ffi.Int32()
  external int micros;
}

/// ! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset
final class duckdb_time_tz extends ffi.Struct {
  @ffi.Uint64()
  external int bits;
}

final class duckdb_time_tz_struct extends ffi.Struct {
  external duckdb_time_struct time;

  @ffi.Int32()
  external int offset;
}

/// ! TIMESTAMP values are stored as microseconds since 1970-01-01.
/// ! Use the duckdb_from_timestamp and duckdb_to_timestamp functions to extract individual information.
final class duckdb_timestamp extends ffi.Struct {
  @ffi.Int64()
  external int micros;
}

/// ! TIMESTAMP_S values are stored as seconds since 1970-01-01.
final class duckdb_timestamp_s extends ffi.Struct {
  @ffi.Int64()
  external int seconds;
}

/// ! TIMESTAMP_MS values are stored as milliseconds since 1970-01-01.
final class duckdb_timestamp_ms extends ffi.Struct {
  @ffi.Int64()
  external int millis;
}

/// ! TIMESTAMP_NS values are stored as nanoseconds since 1970-01-01.
final class duckdb_timestamp_ns extends ffi.Struct {
  @ffi.Int64()
  external int nanos;
}

final class duckdb_timestamp_struct extends ffi.Struct {
  external duckdb_date_struct date;

  external duckdb_time_struct time;
}

final class duckdb_interval extends ffi.Struct {
  @ffi.Int32()
  external int months;

  @ffi.Int32()
  external int days;

  @ffi.Int64()
  external int micros;
}

/// ! Hugeints are composed of a (lower, upper) component
/// ! The value of the hugeint is upper * 2^64 + lower
/// ! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
final class duckdb_hugeint extends ffi.Struct {
  @ffi.Uint64()
  external int lower;

  @ffi.Int64()
  external int upper;
}

final class duckdb_uhugeint extends ffi.Struct {
  @ffi.Uint64()
  external int lower;

  @ffi.Uint64()
  external int upper;
}

/// ! Decimals are composed of a width and a scale, and are stored in a hugeint
final class duckdb_decimal extends ffi.Struct {
  @ffi.Uint8()
  external int width;

  @ffi.Uint8()
  external int scale;

  external duckdb_hugeint value;
}

/// ! A type holding information about the query execution progress
final class duckdb_query_progress_type extends ffi.Struct {
  @ffi.Double()
  external double percentage;

  @ffi.Uint64()
  external int rows_processed;

  @ffi.Uint64()
  external int total_rows_to_process;
}

/// ! The internal representation of a VARCHAR (string_t). If the VARCHAR does not
/// ! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster
/// ! string comparisons and store a pointer to the remaining characters. This is a non-
/// ! owning structure, i.e., it does not have to be freed.
final class duckdb_string_t extends ffi.Struct {
  external UnnamedUnion1 value;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 pointer;

  external UnnamedStruct2 inlined;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.Uint32()
  external int length;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> prefix;

  external ffi.Pointer<ffi.Char> ptr;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Uint32()
  external int length;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Char> inlined;
}

/// ! The internal representation of a list metadata entry contains the list's offset in
/// ! the child vector, and its length. The parent vector holds these metadata entries,
/// ! whereas the child vector holds the data
final class duckdb_list_entry extends ffi.Struct {
  @ffi.Uint64()
  external int offset;

  @ffi.Uint64()
  external int length;
}

/// ! A column consists of a pointer to its internal data. Don't operate on this type directly.
/// ! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,
/// ! duckdb_column_type, and duckdb_column_name, which take the result and the column index
/// ! as their parameters
final class duckdb_column extends ffi.Struct {
  external ffi.Pointer<ffi.Void> deprecated_data;

  external ffi.Pointer<ffi.Bool> deprecated_nullmask;

  @ffi.UnsignedInt()
  external int deprecated_typeAsInt;

  DUCKDB_TYPE get deprecated_type =>
      DUCKDB_TYPE.fromValue(deprecated_typeAsInt);

  external ffi.Pointer<ffi.Char> deprecated_name;

  external ffi.Pointer<ffi.Void> internal_data;
}

/// ! Strings are composed of a char pointer and a size. You must free string.data
/// ! with `duckdb_free`.
final class duckdb_string extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  @idx_t()
  external int size;
}

/// ! DuckDB's index type.
typedef idx_t = ffi.Uint64;
typedef Dartidx_t = int;

/// ! BLOBs are composed of a byte pointer and a size. You must free blob.data
/// ! with `duckdb_free`.
final class duckdb_blob extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @idx_t()
  external int size;
}

/// ! BITs are composed of a byte pointer and a size.
/// ! BIT byte data has 0 to 7 bits of padding.
/// ! The first byte contains the number of padding bits.
/// ! This number of bits of the second byte are set to 1, starting from the MSB.
/// ! You must free `data` with `duckdb_free`.
final class duckdb_bit extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @idx_t()
  external int size;
}

/// ! VARINTs are composed of a byte pointer, a size, and an is_negative bool.
/// ! The absolute value of the number is stored in `data` in little endian format.
/// ! You must free `data` with `duckdb_free`.
final class duckdb_varint extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @idx_t()
  external int size;

  @ffi.Bool()
  external bool is_negative;
}

/// ! A query result consists of a pointer to its internal data.
/// ! Must be freed with 'duckdb_destroy_result'.
final class duckdb_result extends ffi.Struct {
  @idx_t()
  external int deprecated_column_count;

  @idx_t()
  external int deprecated_row_count;

  @idx_t()
  external int deprecated_rows_changed;

  external ffi.Pointer<duckdb_column> deprecated_columns;

  external ffi.Pointer<ffi.Char> deprecated_error_message;

  external ffi.Pointer<ffi.Void> internal_data;
}

/// ! Passed to C API extension as parameter to the entrypoint
final class duckdb_extension_access extends ffi.Struct {
  /// ! Indicate that an error has occurred
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_extension_info info, ffi.Pointer<ffi.Char> error)>>
      set_error;

  /// ! Fetch the database from duckdb to register extensions to
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<duckdb_database> Function(
              duckdb_extension_info info)>> get_database;

  /// ! Fetch the API
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  duckdb_extension_info info, ffi.Pointer<ffi.Char> version)>>
      get_api;
}

/// ! Holds state during the C API extension intialization process
typedef duckdb_extension_info = ffi.Pointer<_duckdb_extension_info>;

/// ! Holds state during the C API extension intialization process
final class _duckdb_extension_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A database object. Must be closed with `duckdb_close`.
typedef duckdb_database = ffi.Pointer<_duckdb_database>;

/// ! A database object. Must be closed with `duckdb_close`.
final class _duckdb_database extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A database instance cache object. Must be destroyed with `duckdb_destroy_instance_cache`.
typedef duckdb_instance_cache = ffi.Pointer<_duckdb_instance_cache>;

/// ! A database instance cache object. Must be destroyed with `duckdb_destroy_instance_cache`.
final class _duckdb_instance_cache extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Can be used to provide start-up options for the DuckDB instance.
/// ! Must be destroyed with `duckdb_destroy_config`.
typedef duckdb_config = ffi.Pointer<_duckdb_config>;

/// ! Can be used to provide start-up options for the DuckDB instance.
/// ! Must be destroyed with `duckdb_destroy_config`.
final class _duckdb_config extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.
typedef duckdb_connection = ffi.Pointer<_duckdb_connection>;

/// ! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.
final class _duckdb_connection extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds an internal logical type.
/// ! Must be destroyed with `duckdb_destroy_logical_type`.
typedef duckdb_logical_type = ffi.Pointer<_duckdb_logical_type>;

/// ! Holds an internal logical type.
/// ! Must be destroyed with `duckdb_destroy_logical_type`.
final class _duckdb_logical_type extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Contains a data chunk from a duckdb_result.
/// ! Must be destroyed with `duckdb_destroy_data_chunk`.
typedef duckdb_data_chunk = ffi.Pointer<_duckdb_data_chunk>;

/// ! Contains a data chunk from a duckdb_result.
/// ! Must be destroyed with `duckdb_destroy_data_chunk`.
final class _duckdb_data_chunk extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A prepared statement is a parameterized query that allows you to bind parameters to it.
/// ! Must be destroyed with `duckdb_destroy_prepare`.
typedef duckdb_prepared_statement = ffi.Pointer<_duckdb_prepared_statement>;

/// ! A prepared statement is a parameterized query that allows you to bind parameters to it.
/// ! Must be destroyed with `duckdb_destroy_prepare`.
final class _duckdb_prepared_statement extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds a DuckDB value, which wraps a type.
/// ! Must be destroyed with `duckdb_destroy_value`.
typedef duckdb_value = ffi.Pointer<_duckdb_value>;

/// ! Holds a DuckDB value, which wraps a type.
/// ! Must be destroyed with `duckdb_destroy_value`.
final class _duckdb_value extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.
typedef duckdb_extracted_statements = ffi.Pointer<_duckdb_extracted_statements>;

/// ! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.
final class _duckdb_extracted_statements extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The pending result represents an intermediate structure for a query that is not yet fully executed.
/// ! Must be destroyed with `duckdb_destroy_pending`.
typedef duckdb_pending_result = ffi.Pointer<_duckdb_pending_result>;

/// ! The pending result represents an intermediate structure for a query that is not yet fully executed.
/// ! Must be destroyed with `duckdb_destroy_pending`.
final class _duckdb_pending_result extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds extra information used when registering a custom logical type.
/// ! Reserved for future use.
typedef duckdb_create_type_info = ffi.Pointer<_duckdb_create_type_info>;

/// ! Holds extra information used when registering a custom logical type.
/// ! Reserved for future use.
final class _duckdb_create_type_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A vector to a specified column in a data chunk. Lives as long as the
/// ! data chunk lives, i.e., must not be destroyed.
typedef duckdb_vector = ffi.Pointer<_duckdb_vector>;

/// ! A vector to a specified column in a data chunk. Lives as long as the
/// ! data chunk lives, i.e., must not be destroyed.
final class _duckdb_vector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`.
typedef duckdb_scalar_function = ffi.Pointer<_duckdb_scalar_function>;

/// ! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`.
final class _duckdb_scalar_function extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The callback that will be called to destroy data, e.g.,
/// ! bind data (if any), init data (if any), extra data for replacement scans (if any)
typedef duckdb_delete_callback_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_delete_callback_tFunction>>;
typedef duckdb_delete_callback_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> data);
typedef Dartduckdb_delete_callback_tFunction = void Function(
    ffi.Pointer<ffi.Void> data);

/// ! The main function of the scalar function.
typedef duckdb_scalar_function_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_scalar_function_tFunction>>;
typedef duckdb_scalar_function_tFunction = ffi.Void Function(
    duckdb_function_info info, duckdb_data_chunk input, duckdb_vector output);
typedef Dartduckdb_scalar_function_tFunction = void Function(
    duckdb_function_info info, duckdb_data_chunk input, duckdb_vector output);

/// ! Additional function info. When setting this info, it is necessary to pass a destroy-callback function.
typedef duckdb_function_info = ffi.Pointer<_duckdb_function_info>;

/// ! Additional function info. When setting this info, it is necessary to pass a destroy-callback function.
final class _duckdb_function_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`.
typedef duckdb_scalar_function_set = ffi.Pointer<_duckdb_scalar_function_set>;

/// ! A scalar function set. Must be destroyed with `duckdb_destroy_scalar_function_set`.
final class _duckdb_scalar_function_set extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`.
typedef duckdb_aggregate_function = ffi.Pointer<_duckdb_aggregate_function>;

/// ! An aggregate function. Must be destroyed with `duckdb_destroy_aggregate_function`.
final class _duckdb_aggregate_function extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Returns the aggregate state size
typedef duckdb_aggregate_state_size
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_state_sizeFunction>>;
typedef duckdb_aggregate_state_sizeFunction = idx_t Function(
    duckdb_function_info info);
typedef Dartduckdb_aggregate_state_sizeFunction = Dartidx_t Function(
    duckdb_function_info info);

/// ! Initialize the aggregate state
typedef duckdb_aggregate_init_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_init_tFunction>>;
typedef duckdb_aggregate_init_tFunction = ffi.Void Function(
    duckdb_function_info info, duckdb_aggregate_state state);
typedef Dartduckdb_aggregate_init_tFunction = void Function(
    duckdb_function_info info, duckdb_aggregate_state state);

/// ! Aggregate state
typedef duckdb_aggregate_state = ffi.Pointer<_duckdb_aggregate_state>;

/// ! Aggregate state
final class _duckdb_aggregate_state extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Update a set of aggregate states with new values
typedef duckdb_aggregate_update_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_update_tFunction>>;
typedef duckdb_aggregate_update_tFunction = ffi.Void Function(
    duckdb_function_info info,
    duckdb_data_chunk input,
    ffi.Pointer<duckdb_aggregate_state> states);
typedef Dartduckdb_aggregate_update_tFunction = void Function(
    duckdb_function_info info,
    duckdb_data_chunk input,
    ffi.Pointer<duckdb_aggregate_state> states);

/// ! Combine aggregate states
typedef duckdb_aggregate_combine_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_combine_tFunction>>;
typedef duckdb_aggregate_combine_tFunction = ffi.Void Function(
    duckdb_function_info info,
    ffi.Pointer<duckdb_aggregate_state> source,
    ffi.Pointer<duckdb_aggregate_state> target,
    idx_t count);
typedef Dartduckdb_aggregate_combine_tFunction = void Function(
    duckdb_function_info info,
    ffi.Pointer<duckdb_aggregate_state> source,
    ffi.Pointer<duckdb_aggregate_state> target,
    Dartidx_t count);

/// ! Finalize aggregate states into a result vector
typedef duckdb_aggregate_finalize_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_finalize_tFunction>>;
typedef duckdb_aggregate_finalize_tFunction = ffi.Void Function(
    duckdb_function_info info,
    ffi.Pointer<duckdb_aggregate_state> source,
    duckdb_vector result,
    idx_t count,
    idx_t offset);
typedef Dartduckdb_aggregate_finalize_tFunction = void Function(
    duckdb_function_info info,
    ffi.Pointer<duckdb_aggregate_state> source,
    duckdb_vector result,
    Dartidx_t count,
    Dartidx_t offset);

/// ! Destroy aggregate state (optional)
typedef duckdb_aggregate_destroy_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_aggregate_destroy_tFunction>>;
typedef duckdb_aggregate_destroy_tFunction = ffi.Void Function(
    ffi.Pointer<duckdb_aggregate_state> states, idx_t count);
typedef Dartduckdb_aggregate_destroy_tFunction = void Function(
    ffi.Pointer<duckdb_aggregate_state> states, Dartidx_t count);

/// ! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`.
typedef duckdb_aggregate_function_set
    = ffi.Pointer<_duckdb_aggregate_function_set>;

/// ! A aggregate function set. Must be destroyed with `duckdb_destroy_aggregate_function_set`.
final class _duckdb_aggregate_function_set extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! A table function. Must be destroyed with `duckdb_destroy_table_function`.
typedef duckdb_table_function = ffi.Pointer<_duckdb_table_function>;

/// ! A table function. Must be destroyed with `duckdb_destroy_table_function`.
final class _duckdb_table_function extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The bind function of the table function.
typedef duckdb_table_function_bind_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_table_function_bind_tFunction>>;
typedef duckdb_table_function_bind_tFunction = ffi.Void Function(
    duckdb_bind_info info);
typedef Dartduckdb_table_function_bind_tFunction = void Function(
    duckdb_bind_info info);

/// ! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function.
typedef duckdb_bind_info = ffi.Pointer<_duckdb_bind_info>;

/// ! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function.
final class _duckdb_bind_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The (possibly thread-local) init function of the table function.
typedef duckdb_table_function_init_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_table_function_init_tFunction>>;
typedef duckdb_table_function_init_tFunction = ffi.Void Function(
    duckdb_init_info info);
typedef Dartduckdb_table_function_init_tFunction = void Function(
    duckdb_init_info info);

/// ! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function.
typedef duckdb_init_info = ffi.Pointer<_duckdb_init_info>;

/// ! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function.
final class _duckdb_init_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The main function of the table function.
typedef duckdb_table_function_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_table_function_tFunction>>;
typedef duckdb_table_function_tFunction = ffi.Void Function(
    duckdb_function_info info, duckdb_data_chunk output);
typedef Dartduckdb_table_function_tFunction = void Function(
    duckdb_function_info info, duckdb_data_chunk output);

/// ! A replacement scan function that can be added to a database.
typedef duckdb_replacement_callback_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_replacement_callback_tFunction>>;
typedef duckdb_replacement_callback_tFunction = ffi.Void Function(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> table_name,
    ffi.Pointer<ffi.Void> data);
typedef Dartduckdb_replacement_callback_tFunction = void Function(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> table_name,
    ffi.Pointer<ffi.Void> data);

/// ! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function.
typedef duckdb_replacement_scan_info
    = ffi.Pointer<_duckdb_replacement_scan_info>;

/// ! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function.
final class _duckdb_replacement_scan_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds a recursive tree that matches the query plan.
typedef duckdb_profiling_info = ffi.Pointer<_duckdb_profiling_info>;

/// ! Holds a recursive tree that matches the query plan.
final class _duckdb_profiling_info extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The appender enables fast data loading into DuckDB.
/// ! Must be destroyed with `duckdb_appender_destroy`.
typedef duckdb_appender = ffi.Pointer<_duckdb_appender>;

/// ! The appender enables fast data loading into DuckDB.
/// ! Must be destroyed with `duckdb_appender_destroy`.
final class _duckdb_appender extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! The table description allows querying info about the table.
/// ! Must be destroyed with `duckdb_table_description_destroy`.
typedef duckdb_table_description = ffi.Pointer<_duckdb_table_description>;

/// ! The table description allows querying info about the table.
/// ! Must be destroyed with `duckdb_table_description_destroy`.
final class _duckdb_table_description extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.
typedef duckdb_arrow = ffi.Pointer<_duckdb_arrow>;

/// ! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.
final class _duckdb_arrow extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds an arrow schema. Remember to release the respective ArrowSchema object.
typedef duckdb_arrow_schema = ffi.Pointer<_duckdb_arrow_schema>;

/// ! Holds an arrow schema. Remember to release the respective ArrowSchema object.
final class _duckdb_arrow_schema extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds an arrow array. Remember to release the respective ArrowArray object.
typedef duckdb_arrow_array = ffi.Pointer<_duckdb_arrow_array>;

/// ! Holds an arrow array. Remember to release the respective ArrowArray object.
final class _duckdb_arrow_array extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.
typedef duckdb_arrow_stream = ffi.Pointer<_duckdb_arrow_stream>;

/// ! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.
final class _duckdb_arrow_stream extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

/// ! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`.
typedef duckdb_task_state = ffi.Pointer<ffi.Void>;

/// ! A cast function. Must be destroyed with `duckdb_destroy_cast_function`.
typedef duckdb_cast_function = ffi.Pointer<_duckdb_cast_function>;

/// ! A cast function. Must be destroyed with `duckdb_destroy_cast_function`.
final class _duckdb_cast_function extends ffi.Struct {
  external ffi.Pointer<ffi.Void> internal_ptr;
}

typedef duckdb_cast_function_t
    = ffi.Pointer<ffi.NativeFunction<duckdb_cast_function_tFunction>>;
typedef duckdb_cast_function_tFunction = ffi.Bool Function(
    duckdb_function_info info,
    idx_t count,
    duckdb_vector input,
    duckdb_vector output);
typedef Dartduckdb_cast_function_tFunction = bool Function(
    duckdb_function_info info,
    Dartidx_t count,
    duckdb_vector input,
    duckdb_vector output);
